using UnityEngine;
using UnityEngine.UI;
using System.Collections.Generic;

// VERSI√ìN CORREGIDA - FIX PARA PROBLEMA DE JOYSTICK
// ‚úÖ Separaci√≥n correcta de rotaci√≥n horizontal y alineaci√≥n con terreno
// ‚úÖ Sin conflictos de direcci√≥n al girar
// ‚úÖ Movimiento suave y predecible

public class SimpleDinosaurController : MonoBehaviour
{
    [Header("Referencias")]
    public Animator animator;
    public AudioSource audioSource;
    public Transform cameraTransform;
    
    [Header("Controles T√°ctiles")]
    public VariableJoystick movementJoystick;
    public Button runButton;
    public Button callButton;
    public Button jumpButton;
    public Button attackButton;
    public Button sleepButton;

    [Header("üìè CONFIGURACI√ìN DE TAMA√ëO DEL DINOSAURIO")]
    [Tooltip("Selecciona el tama√±o del dinosaurio para aplicar valores preconfigurados")]
    public DinosaurSize dinosaurSize = DinosaurSize.Medium;
    [Tooltip("Altura real del modelo (usado para c√°lculos autom√°ticos)")]
    public float modelHeight = 2.5f;
    [Space(10)]
    [Tooltip("Haz click derecho en el script ‚Üí 'Apply Size Preset' para aplicar configuraci√≥n autom√°tica")]
    public bool autoConfigureOnStart = false;

    public enum DinosaurSize
    {
        Small,      // 1-2m (Compsognathus, Velociraptor joven)
        Medium,     // 3-5m (Velociraptor, Dilophosaurus)
        Large,      // 6-10m (T-Rex, Spinosaurus)
        Custom      // Valores manuales 
    }

    [Header("Velocidades")]
    public float walkSpeed = 2f;
    public float runSpeed = 5f;
    public float turnSpeed = 120f;
    
    [Header("üîÑ CONFIGURACI√ìN DE RADIO DE GIRO - MEJORADO")]
    [Tooltip("Radio m√≠nimo de giro al caminar")]
    public float walkTurnRadius = 1.5f;
    [Tooltip("Radio m√≠nimo de giro al correr")]
    public float runTurnRadius = 3f;
    [Tooltip("Suavizado del giro (m√°s alto = m√°s suave)")]
    [Range(1f, 10f)]
    public float turnSmoothness = 5f;
    [Tooltip("Velocidad m√°xima de rotaci√≥n (grados/segundo)")]
    public float maxRotationSpeed = 180f;
    [Tooltip("Factor de suavizado de direcci√≥n")]
    [Range(0.1f, 1f)]
    public float directionSmoothFactor = 0.3f;
    [Tooltip("Tolerancia para considerar que el dinosaurio est√° mirando hacia el objetivo")]
    [Range(5f, 45f)]
    public float lookAtTolerance = 15f;
    [Tooltip("Factor de velocidad durante el giro (reduce velocidad al girar)")]
    [Range(0.3f, 1f)]
    public float turningSpeedFactor = 0.7f;
    
    [Header("‚≠ê CONFIGURACI√ìN DE SALTO")]
    [Tooltip("Altura del salto")]
    public float jumpHeight = 2f;
    [Tooltip("Tiempo de espera entre saltos (despu√©s de aterrizar)")]
    public float jumpCooldown = 1f;
	
	[Header("‚≠ê SALTO - Coyote & Buffer")]
	[Tooltip("Tiempo (s) que permitido saltar despu√©s de despegar (coyote time)")]
	public float coyoteTime = 0.12f;
	[Tooltip("Tiempo (s) para guardar input de salto antes de aterrizar (jump buffer)")]
	public float jumpBufferTime = 0.12f;

	private float lastGroundedTime = -10f;  // ‚úÖ Variable unificada
	private float jumpBufferTimerLocal = 0f;
    
    [Header("‚≠ê CONFIGURACI√ìN DE GRAVEDAD")]
    [Tooltip("Fuerza de gravedad (m√°s negativo = cae m√°s r√°pido)")]
    public float gravity = -20f;
    [Tooltip("Velocidad terminal de ca√≠da")]
    public float terminalVelocity = -50f;
    
    [Header("üèîÔ∏è CONFIGURACI√ìN DE PENDIENTES")]
    [Tooltip("Multiplicador de velocidad en subidas (mayor = sube m√°s r√°pido)")]
    [Range(0.5f, 2f)]
    public float slopeSpeedMultiplier = 1.2f;
    [Tooltip("Fuerza extra al bajar pendientes")]
    public float slopeForceDown = 10f;
    [Tooltip("‚≠ê Alinear modelo con el terreno")]
    public bool alignToTerrain = true;
    [Tooltip("Velocidad de alineaci√≥n con el terreno")]
    [Range(1f, 20f)]
    public float terrainAlignmentSpeed = 8f;
    [Tooltip("M√°ximo √°ngulo de inclinaci√≥n permitido")]
    [Range(0f, 90f)]
    public float maxTerrainTilt = 45f;
    
    [Header("‚öîÔ∏è SISTEMA DE ATAQUE - MEJORADO")]
    [Tooltip("Da√±o que hace cada ataque")]
    public float attackDamage = 25f;
    [Tooltip("Rango del ataque (distancia)")]
    public float attackRange = 2f;
    [Tooltip("√Ångulo del ataque (cono frontal)")]
    [Range(0f, 180f)]
    public float attackAngle = 90f;
    [Tooltip("‚≠ê Tiempo de espera entre ataques - REDUCIDO para mejor respuesta")]
    public float attackCooldown = 0.5f;
    [Tooltip("Duraci√≥n del ataque (animaci√≥n)")]
    public float attackDuration = 0.5f;
    [Tooltip("Layer de enemigos (objetos que pueden recibir da√±o)")]
    public LayerMask enemyLayer;
    [Tooltip("Punto desde donde sale el ataque (boca del dinosaurio)")]
    public Transform attackPoint;
    [Tooltip("Mostrar √°rea de ataque en el editor")]
    public bool showAttackGizmos = true;
    
    [Header("‚öîÔ∏è NUEVAS MEJORAS DE ATAQUE")]
    [Tooltip("‚≠ê Permitir buffer de input (guarda el ataque para despu√©s)")]
    public bool enableAttackBuffer = true;
    [Tooltip("‚≠ê Tiempo que se guarda el input de ataque")]
    public float attackBufferTime = 0.3f;
    [Tooltip("‚≠ê Tolerancia al estar 'en el suelo' para atacar")]
    public float groundedTolerance = 0.2f;
    [Tooltip("‚≠ê Permitir atacar en el aire")]
    public bool canAttackInAir = true;
    
    [Header("‚öîÔ∏è EFECTOS DE ATAQUE")]
    [Tooltip("Fuerza de empuje al atacar")]
    public float attackKnockback = 5f;
    [Tooltip("Puede moverse mientras ataca")]
    public bool canMoveWhileAttacking = false;
    [Tooltip("Puede rotar mientras ataca")]
    public bool canRotateWhileAttacking = true;
    
    [Header("üéµ AUDIO DE ATAQUE")]
    public AudioClip[] attackSounds;
    public AudioClip[] hitSounds;
	
	[Header("üé§ Call / Roar Settings")]
	[Tooltip("Duraci√≥n del rugido (segundos)")]
	public float callDuration = 2.5f; // ajusta seg√∫n la duraci√≥n de tu animaci√≥n
	private bool isCalling = false;
	private float callTimer = 0f;
    
    [Header("üîÑ CONFIGURACI√ìN DE TURN Y LOOK - BASADO EN C√ÅMARA")]
    [Tooltip("Activar poses est√°ticas de giro")]
    public bool enableStaticTurn = true;
    [Tooltip("Activar poses de mirada arriba/abajo")]
    public bool enableVerticalLook = true;
    [Tooltip("Umbral para detectar cambio de c√°mara (grados)")]
    public float turnDetectionThreshold = 30f;
    [Tooltip("Umbral para detectar cambio de c√°mara vertical (grados)")]
    public float lookDetectionThreshold = 20f;
    [Tooltip("√Ångulo para detectar frente/atr√°s")]
    public float frontBackAngle = 45f;
    [Tooltip("Velocidad de transici√≥n entre poses de giro")]
    [Range(1f, 10f)]
    public float turnTransitionSpeed = 4f;
    [Tooltip("Velocidad de transici√≥n entre poses de mirada vertical")]
    [Range(1f, 10f)]
    public float lookTransitionSpeed = 4f;
    [Tooltip("‚≠ê L√≠mite m√°ximo de Turn y Look (evita poses est√°ticas)")]
    [Range(0.5f, 1f)]
    public float maxTurnLookValue = 0.80f;
    
    [Header("Configuraci√≥n de Movimiento")]
    public float turnInPlaceThreshold = 0.1f;
    public float movementThreshold = 0.2f;
    [Tooltip("Suavizado del movimiento")]
    [Range(1f, 20f)]
    public float movementSmoothness = 10f;
    
    [Header("Audio")]
    public AudioClip[] walkSounds;
    public AudioClip[] runSounds;
    public AudioClip[] callSounds;
    public AudioClip[] jumpSounds;
    public AudioClip[] landSounds;

    [Header("üåä SISTEMA DE NATACI√ìN")]
    [Tooltip("Layer del agua (debe tener Trigger activado)")]
    public LayerMask waterLayer;
    [Tooltip("Velocidad de nataci√≥n")]
    public float swimSpeed = 3f;
    [Tooltip("Fuerza de flotaci√≥n (empuje hacia arriba)")]
    public float buoyancyForce = 9.8f;
    [Tooltip("Resistencia del agua (frena movimiento)")]
    [Range(0.5f, 0.95f)]
    public float waterDrag = 0.8f;
    [Tooltip("Altura del agua donde empieza a flotar")]
    public float waterSurfaceOffset = 1f;
    [Tooltip("Tolerancia para evitar parpadeo entre estados (0.5 = 50% del offset)")]
    [Range(0.3f, 0.8f)]
    public float waterHysteresis = 0.6f;
    [Tooltip("Permitir salto desde el agua")]
    public bool canJumpFromWater = false;

    [Header("üò¥ SISTEMA DE SUE√ëO")]
    [Tooltip("Duraci√≥n de la animaci√≥n de entrar a dormir (segundos)")]
    public float sleepEnterDuration = 2f;
    [Tooltip("Duraci√≥n de la animaci√≥n de salir del sue√±o (segundos)")]
    public float sleepExitDuration = 1.5f;
    [Tooltip("Mostrar efectos Z al dormir")]
    public bool showSleepEffects = true;

    [Header("üçñ SISTEMA DE NECESIDADES")]
    [Tooltip("Nivel de hambre (0 = lleno, 100 = m√°ximo hambre)")]
    [Range(0f, 100f)]
    public float hunger = 0f;
    [Tooltip("Nivel de sed (0 = hidratado, 100 = m√°xima sed)")]
    [Range(0f, 100f)]
    public float thirst = 0f;
    [Tooltip("Nivel de estamina (0 = agotado, 100 = m√°xima energ√≠a)")]
    [Range(0f, 100f)]
    public float stamina = 100f;

    [Header("üçñ Configuraci√≥n de Hambre y Sed")]
    [Tooltip("Velocidad de aumento de hambre por segundo")]
    public float hungerIncreaseRate = 1f;
    [Tooltip("Velocidad de aumento de sed por segundo")]
    public float thirstIncreaseRate = 1.5f;
    [Tooltip("Cantidad de hambre que se reduce por segundo al comer")]
    public float hungerDecreaseRateWhileEating = 15f;
    [Tooltip("Cantidad de sed que se reduce por segundo al beber")]
    public float thirstDecreaseRateWhileDrinking = 20f;

    [Header("‚ö° Configuraci√≥n de Estamina")]
    [Tooltip("Cantidad de estamina que se gasta por segundo al correr")]
    public float staminaDrainRate = 10f;
    [Tooltip("Cantidad de estamina que se regenera por segundo al estar quieto")]
    public float staminaRegenRate = 5f;
    [Tooltip("Multiplicador de regeneraci√≥n de estamina al dormir")]
    public float staminaRegenMultiplierWhenSleeping = 3f;
    [Tooltip("Estamina m√≠nima requerida para poder correr")]
    public float minStaminaToRun = 10f;

    [Header("üçñ Sistema de Comida")]
    [Tooltip("Tag de objetos de comida")]
    public string foodTag = "Food";
    [Tooltip("Distancia m√°xima para detectar comida")]
    public float foodDetectionRange = 3f;
    [Tooltip("Bot√≥n UI para comer")]
    public Button eatButton;
    [Tooltip("Duraci√≥n de la animaci√≥n de comer")]
    public float eatAnimationDuration = 2f;

    [Header("üíß Sistema de Agua (Beber)")]
    [Tooltip("Tag de objetos de agua potable")]
    public string drinkableWaterTag = "WaterSource";
    [Tooltip("Distancia m√°xima para detectar agua potable")]
    public float waterDetectionRange = 3f;
    [Tooltip("Bot√≥n UI para beber")]
    public Button drinkButton;
    [Tooltip("Duraci√≥n de la animaci√≥n de beber")]
    public float drinkAnimationDuration = 2f;

    // Estados
    public enum MovementState
    {
        Idle = 0,
        Walk = 1,
        Run = 2,
        Jump = 3,
        Falling = 4,
        Attacking = 5,
        Swimming = 6,
        IdleSwim = 7,
        SleepEnter = 8,
        Sleeping = 9,
        SleepExit = 10,
        Eating = 11,
        Drinking = 12
    }

    public enum SleepState
    {
        Awake,
        EnteringSleep,
        Sleeping,
        ExitingSleep
    }
    
    public enum TurnState
    {
        Idle = 0,
        TurnLeft = -1,
        TurnRight = 1
    }
    
    [Header("Estado Actual")]
    public MovementState currentState = MovementState.Idle;
    public TurnState currentTurnState = TurnState.Idle;
    public bool isRunning = false;
    public bool isOnSlope = false;
    public float currentSlopeAngle = 0f;
    public bool isAttacking = false;
    public int enemiesInRange = 0;
    public bool isInWater = false;
    public bool isSwimming = false;

    // üò¥ Variables de estado de sue√±o
    public SleepState currentSleepState = SleepState.Awake;
    private bool isSleeping = false;
    private float sleepStateTimer = 0f;

    // üçñ Variables de estado de comida y bebida
    private bool isEating = false;
    private bool isDrinking = false;
    private GameObject nearestFood = null;
    private GameObject nearestWaterSource = null;
    private bool isFoodInRange = false;
    private bool isWaterSourceInRange = false;

    // Character Controller
    private CharacterController controller;
    
    // Variables de movimiento
    private Vector3 inputVector;
    private Vector3 moveDirection;
    private Vector3 velocity;
    private float currentSpeed = 0f;
    private float targetSpeed = 0f;
    
    // ‚≠ê VARIABLES DE RADIO DE GIRO NATURAL
    private Vector3 currentMoveDirection;
    private Vector3 targetMoveDirection;
    private Vector3 smoothedMoveDirection;
    private float currentTurnRadius = 0f;
    
    // ‚≠ê FIX: Variables separadas para rotaci√≥n
    private float currentYaw = 0f;  // Rotaci√≥n horizontal (controlada por joystick)
    private Quaternion terrainRotation = Quaternion.identity;  // Rotaci√≥n del terreno (pitch/roll)
    
    // Variables de salto
    private bool canJump = true;
    private float jumpCooldownTimer = 0f;
    private bool hasJumped = false;
    
    // Variables de ataque
    private float attackCooldownTimer = 0f;
    private float attackTimer = 0f;
    private bool attackBuffered = false;
    private float attackBufferTimer = 0f;
    private List<GameObject> enemiesHit = new List<GameObject>();
    
    // Variables de detecci√≥n de pendiente
    private RaycastHit slopeHit;
    private Vector3 slopeNormal;
    
    // ‚≠ê Variables para alineaci√≥n con terreno
    private Vector3 smoothNormal = Vector3.up;
    
    // Variables de animaci√≥n Turn/Look basado en c√°mara
    private float currentTurn = 0f;
    private float targetTurn = 0f;
    private float currentLook = 0f;
    private float targetLook = 0f;
    private float lastCameraAngle = 0f;
    private float lastCameraVerticalAngle = 0f;

    // üåä Variables de nataci√≥n
    private Collider waterCollider = null;
    private float waterSurfaceY = 0f;
    private bool wasInWater = false;


    void Start()
    {
        controller = GetComponent<CharacterController>();
        if (controller == null)
        {
            controller = gameObject.AddComponent<CharacterController>();
            controller.height = 2f;
            controller.center = new Vector3(0, 1f, 0);
            controller.radius = 0.5f;
        }
        
        if (animator == null)
            animator = GetComponent<Animator>();
        
        if (audioSource == null)
            audioSource = GetComponent<AudioSource>();
        
        if (cameraTransform == null)
        {
            Camera mainCam = Camera.main;
            if (mainCam != null)
                cameraTransform = mainCam.transform;
        }
        
        if (attackPoint == null)
            attackPoint = transform;
        
        // Inicializar rotaci√≥n
        currentYaw = transform.eulerAngles.y;

        // üìè Auto-configurar tama√±o si est√° activado
        if (autoConfigureOnStart && dinosaurSize != DinosaurSize.Custom)
        {
            ApplySizePreset();
        }

        SetupButtonListeners();
    }
    
    void SetupButtonListeners()
    {
        if (runButton != null)
        {
            runButton.onClick.RemoveAllListeners();
            runButton.onClick.AddListener(() => isRunning = !isRunning);
        }

        if (callButton != null)
        {
            callButton.onClick.RemoveAllListeners();
            callButton.onClick.AddListener(PlayCallSound);
        }

        if (jumpButton != null)
        {
            jumpButton.onClick.RemoveAllListeners();
            jumpButton.onClick.AddListener(TryJump);
        }

        if (attackButton != null)
        {
            attackButton.onClick.RemoveAllListeners();
            attackButton.onClick.AddListener(TryAttack);
        }

        if (sleepButton != null)
        {
            sleepButton.onClick.RemoveAllListeners();
            sleepButton.onClick.AddListener(ToggleSleep);
        }

        if (eatButton != null)
        {
            eatButton.onClick.RemoveAllListeners();
            eatButton.onClick.AddListener(ToggleEating);
            eatButton.gameObject.SetActive(false); // Ocultar por defecto
        }

        if (drinkButton != null)
        {
            drinkButton.onClick.RemoveAllListeners();
            drinkButton.onClick.AddListener(ToggleDrinking);
            drinkButton.gameObject.SetActive(false); // Ocultar por defecto
        }
    }

    // üìè SISTEMA DE CONFIGURACI√ìN AUTOM√ÅTICA POR TAMA√ëO
    [ContextMenu("Apply Size Preset")]
    public void ApplySizePreset()
    {
        if (dinosaurSize == DinosaurSize.Custom)
        {
            Debug.LogWarning("‚ö†Ô∏è Tama√±o configurado como 'Custom'. No se aplicar√°n presets autom√°ticos.");
            return;
        }

        Debug.Log($"üìè Aplicando preset de tama√±o: {dinosaurSize} (Altura: {modelHeight}m)");

        switch (dinosaurSize)
        {
            case DinosaurSize.Small:
                ApplySmallPreset();
                break;
            case DinosaurSize.Medium:
                ApplyMediumPreset();
                break;
            case DinosaurSize.Large:
                ApplyLargePreset();
                break;
        }

        // Actualizar Character Controller
        if (controller != null)
        {
            controller.height = modelHeight;
            controller.radius = modelHeight * 0.2f;
            controller.center = new Vector3(0, modelHeight * 0.5f, 0);
        }

        Debug.Log($"‚úÖ Configuraci√≥n aplicada: Walk={walkSpeed}, Run={runSpeed}, Swim={swimSpeed}, WaterOffset={waterSurfaceOffset}");
    }

    void ApplySmallPreset()
    {
        // Velocidades
        walkSpeed = modelHeight * 1.2f;
        runSpeed = modelHeight * 2.5f;
        swimSpeed = modelHeight * 1.2f;
        turnSpeed = 180f;

        // Salto
        jumpHeight = modelHeight * 0.8f;
        jumpCooldown = 0.5f;

        // Gravedad
        gravity = -25f;
        terminalVelocity = -40f;

        // Agua
        waterSurfaceOffset = modelHeight * 0.5f;
        buoyancyForce = 15f;
        waterDrag = 0.75f;
        waterHysteresis = 0.6f;

        // Ataque
        attackRange = modelHeight * 0.6f;
        attackDamage = modelHeight * 10f;

        // Giro
        walkTurnRadius = 1.0f;
        runTurnRadius = 2.0f;
        maxRotationSpeed = 200f;
    }

    void ApplyMediumPreset()
    {
        // Velocidades
        walkSpeed = modelHeight * 1.0f;
        runSpeed = modelHeight * 2.2f;
        swimSpeed = modelHeight * 1.2f;
        turnSpeed = 120f;

        // Salto
        jumpHeight = modelHeight * 0.6f;
        jumpCooldown = 1.0f;

        // Gravedad
        gravity = -20f;
        terminalVelocity = -50f;

        // Agua
        waterSurfaceOffset = modelHeight * 0.45f;
        buoyancyForce = 9.8f;
        waterDrag = 0.80f;
        waterHysteresis = 0.6f;

        // Ataque
        attackRange = modelHeight * 0.5f;
        attackDamage = modelHeight * 10f;

        // Giro
        walkTurnRadius = 1.5f;
        runTurnRadius = 3.0f;
        maxRotationSpeed = 180f;
    }

    void ApplyLargePreset()
    {
        // Velocidades
        walkSpeed = modelHeight * 0.7f;
        runSpeed = modelHeight * 1.6f;
        swimSpeed = modelHeight * 0.9f;
        turnSpeed = 90f;

        // Salto
        jumpHeight = modelHeight * 0.4f;
        jumpCooldown = 2.0f;

        // Gravedad
        gravity = -15f;
        terminalVelocity = -60f;

        // Agua
        waterSurfaceOffset = modelHeight * 0.4f;
        buoyancyForce = 8f;
        waterDrag = 0.85f;
        waterHysteresis = 0.6f;

        // Ataque
        attackRange = modelHeight * 0.5f;
        attackDamage = modelHeight * 15f;

        // Giro
        walkTurnRadius = 2.5f;
        runTurnRadius = 5.0f;
        maxRotationSpeed = 120f;
    }

    void Update()
    {
        // Leer input del joystick
        GetInput();
        
        // Detectar pendientes
        CheckSlope();
        
        // Calcular movimiento y rotaci√≥n
        CalculateMovement();
        
        // ‚≠ê FIX: Aplicar rotaci√≥n separada
        ApplySeparatedRotation();
        
        // Aplicar movimiento
        ApplyMovement();

        // ‚≠ê Alinear con el terreno (solo afecta pitch/roll, no yaw)
        // üåä NO alinear cuando est√° nadando
        if (alignToTerrain && controller.isGrounded && !isSwimming)
        {
            AlignToTerrainFixed();
        }

        // üåä Resetear rotaci√≥n a horizontal cuando est√° nadando
        if (isSwimming)
        {
            ResetRotationToHorizontal();
        }

        // Actualizar animaciones
        UpdateAnimations();
        
        // Actualizar sistema de ataque
        UpdateAttackSystem();
        
        // Actualizar Turn y Look basado en c√°mara
        UpdateCameraBasedTurnAndLook();

        // Actualizar sistema de sue√±o
        UpdateSleepSystem();

        // üçñ Actualizar sistema de necesidades
        UpdateNeedsSystem();

        // üçñ Detectar comida y agua cercana
        DetectFoodAndWater();

        // üçñ Actualizar sistemas de comer y beber
        UpdateEatingSystem();
        UpdateDrinkingSystem();

        // Actualizar timers
        UpdateTimers();

        // Actualizar estado
        UpdateState();

        // Actualizar UI
        UpdateUI();
    }
    
    void GetInput()
    {
        // üò¥ No leer input si est√° durmiendo
        if (isSleeping)
        {
            inputVector = Vector3.zero;
            return;
        }

        // üçñ No leer input si est√° comiendo o bebiendo
        if (isEating || isDrinking)
        {
            inputVector = Vector3.zero;
            return;
        }

        if (movementJoystick != null)
        {
            inputVector = new Vector3(movementJoystick.Horizontal, 0, movementJoystick.Vertical);
        }
        else
        {
            inputVector = new Vector3(Input.GetAxis("Horizontal"), 0, Input.GetAxis("Vertical"));
        }

        // Limitar magnitud
        if (inputVector.magnitude > 1f)
            inputVector = inputVector.normalized;
    }
    
    void CheckSlope()
    {
        if (controller.isGrounded)
        {
            Vector3 origin = transform.position + Vector3.up * 0.5f;
            if (Physics.Raycast(origin, Vector3.down, out slopeHit, controller.height))
            {
                slopeNormal = slopeHit.normal;
                currentSlopeAngle = Vector3.Angle(Vector3.up, slopeNormal);
                isOnSlope = currentSlopeAngle > 1f && currentSlopeAngle < controller.slopeLimit;
            }
            else
            {
                isOnSlope = false;
                currentSlopeAngle = 0f;
                slopeNormal = Vector3.up;
            }
        }
        else
        {
            isOnSlope = false;
            currentSlopeAngle = 0f;
            slopeNormal = Vector3.up;
        }
    }
    
    void CalculateMovement()
    {
        // ‚≠ê FIX: Calcular direcci√≥n relativa a la c√°mara de forma m√°s estable
        if (inputVector.magnitude > turnInPlaceThreshold)
        {
            // Obtener vectores de la c√°mara
            Vector3 cameraForward = cameraTransform.forward;
            Vector3 cameraRight = cameraTransform.right;
            
            // Proyectar en plano horizontal
            cameraForward.y = 0;
            cameraRight.y = 0;
            cameraForward.Normalize();
            cameraRight.Normalize();
            
            // Calcular direcci√≥n deseada basada en el input del joystick
            targetMoveDirection = (cameraForward * inputVector.z + cameraRight * inputVector.x).normalized;
            
            // Si estamos atacando y no podemos movernos, mantener direcci√≥n actual
            if (isAttacking && !canMoveWhileAttacking)
            {
                targetMoveDirection = transform.forward;
            }
            
            // Suavizar la direcci√≥n de movimiento
            if (currentMoveDirection == Vector3.zero)
            {
                currentMoveDirection = targetMoveDirection;
            }
            else
            {
                currentMoveDirection = Vector3.Slerp(currentMoveDirection, targetMoveDirection, 
                    Time.deltaTime * turnSmoothness);
            }
            
            // üåä Calcular velocidad objetivo (diferente en agua)
            if (isInWater && isSwimming)
            {
                targetSpeed = swimSpeed;  // Velocidad de nataci√≥n
            }
            else
            {
                // ‚ö° Verificar estamina antes de correr
                bool canRun = isRunning && stamina >= minStaminaToRun;
                targetSpeed = canRun ? runSpeed : walkSpeed;

                // Si intentaba correr pero no tiene estamina, forzar caminar
                if (isRunning && !canRun)
                {
                    isRunning = false;
                }
            }

            // Reducir velocidad durante el giro (no aplica en agua)
            if (!isInWater)
            {
                float angleToTarget = Vector3.Angle(transform.forward, currentMoveDirection);
                if (angleToTarget > lookAtTolerance)
                {
                    targetSpeed *= turningSpeedFactor;
                }
            }

            // Aplicar modificador de pendiente (no aplica en agua)
            if (isOnSlope && !isInWater)
            {
                float slopeFactor = Vector3.Dot(currentMoveDirection, slopeNormal);
                if (slopeFactor < 0) // Subiendo
                {
                    targetSpeed *= slopeSpeedMultiplier;
                }
            }
        }
        else
        {
            // Sin input
            targetSpeed = 0f;
            if (currentMoveDirection.magnitude > 0.1f)
            {
                currentMoveDirection = Vector3.Lerp(currentMoveDirection, Vector3.zero, Time.deltaTime * 5f);
            }
        }
        
        // Suavizar velocidad
        currentSpeed = Mathf.Lerp(currentSpeed, targetSpeed, Time.deltaTime * movementSmoothness);
        
        // Calcular direcci√≥n de movimiento final
        moveDirection = transform.forward * currentSpeed;

        
        // Si no podemos movernos mientras atacamos
        if (isAttacking && !canMoveWhileAttacking)
        {
            moveDirection = Vector3.zero;
        }
    }
    
void ApplySeparatedRotation()
{
    if (inputVector.magnitude > turnInPlaceThreshold)
    {
        if (!isAttacking || canRotateWhileAttacking)
        {
            if (targetMoveDirection != Vector3.zero)
            {
                // Calcular √°ngulo objetivo (direcci√≥n deseada)
                float targetYaw = Mathf.Atan2(targetMoveDirection.x, targetMoveDirection.z) * Mathf.Rad2Deg;
                float angleDifference = Mathf.DeltaAngle(currentYaw, targetYaw);

                // Radio din√°mico de giro (seg√∫n velocidad)
                currentTurnRadius = isRunning ? runTurnRadius : walkTurnRadius;

                // Calcular velocidad de rotaci√≥n
                float rotationStep = Mathf.Clamp(angleDifference, -maxRotationSpeed * Time.deltaTime, maxRotationSpeed * Time.deltaTime);
                currentYaw += rotationStep;

                // Aplicar rotaci√≥n suave al transform
                Vector3 eulerRotation = transform.eulerAngles;
                eulerRotation.y = currentYaw;
                transform.eulerAngles = eulerRotation;

                // ‚≠ê Actualizar direcci√≥n de movimiento para que siga la curva
                Quaternion turnRotation = Quaternion.Euler(0f, rotationStep * (1f / currentTurnRadius), 0f);
                currentMoveDirection = turnRotation * currentMoveDirection;

                // Moverse siguiendo el giro
                moveDirection = transform.forward * currentSpeed;
            }
        }
    }
    else
    {
        // Sin input, mantener orientaci√≥n actual
        Vector3 eulerRotation = transform.eulerAngles;
        eulerRotation.y = currentYaw;
        transform.eulerAngles = eulerRotation;
    }
}


    
void ApplyMovement()
{
    // ‚úÖ ACTUALIZAR TIEMPO EN SUELO PRIMERO
    bool wasGrounded = controller.isGrounded;

    // üåä SISTEMA DE NATACI√ìN
    if (isInWater)
    {
        // ‚úÖ Calcular profundidad real del agua (desde el centro del personaje)
        float waterDepth = waterSurfaceY - transform.position.y;
        bool isDeepEnoughToSwim = waterDepth >= waterSurfaceOffset;

        if (isDeepEnoughToSwim)
        {
            // üèä AGUA PROFUNDA - ACTIVAR NATACI√ìN

            // ‚úÖ FLOTACI√ìN - aplicar fuerza hacia arriba
            velocity.y += buoyancyForce * Time.deltaTime;

            // Limitar velocidad vertical en agua
            velocity.y = Mathf.Clamp(velocity.y, -2f, 2f);

            // Aplicar resistencia del agua (drag)
            velocity *= waterDrag;

            // Determinar si est√° nadando (movi√©ndose)
            isSwimming = inputVector.magnitude > 0.1f;

            // No resetear hasJumped en agua (a menos que se permita saltar desde agua)
            if (canJumpFromWater)
            {
                canJump = true;
                hasJumped = false;
            }
        }
        else
        {
            // üö∂ AGUA POCO PROFUNDA - CAMINAR NORMALMENTE

            isSwimming = false;

            // Aplicar f√≠sica normal como en tierra
            if (controller.isGrounded && velocity.y < 0f)
            {
                velocity.y = -2f;
            }

            // Aplicar gravedad normal
            velocity.y += gravity * Time.deltaTime;
            velocity.y = Mathf.Max(velocity.y, terminalVelocity);

            // Aplicar fuerza adicional si est√° en pendiente
            if (isOnSlope && controller.isGrounded)
            {
                velocity += Vector3.down * slopeForceDown * Time.deltaTime;
            }
        }
    }
    else
    {
        // üèÉ MOVIMIENTO NORMAL (FUERA DEL AGUA)

        // Mantener pegado al suelo (evita saltos falsos cuando ya est√° en tierra)
        if (controller.isGrounded && velocity.y < 0f)
        {
            velocity.y = -2f;
        }

        // Aplicar gravedad
        velocity.y += gravity * Time.deltaTime;
        velocity.y = Mathf.Max(velocity.y, terminalVelocity);

        // Aplicar fuerza adicional si est√° en pendiente
        if (isOnSlope && controller.isGrounded)
        {
            velocity += Vector3.down * slopeForceDown * Time.deltaTime;
        }

        isSwimming = false;
    }

    // Combinar movimiento horizontal y vertical
    Vector3 finalMove = moveDirection + velocity;

    // Aplicar movimiento
    controller.Move(finalMove * Time.deltaTime);

    // ‚úÖ ACTUALIZAR ESTADO DE SUELO DESPU√âS DEL MOVIMIENTO
    if (controller.isGrounded && !isSwimming)
    {
        lastGroundedTime = Time.time;

        // üîπ Resetear hasJumped cuando aterriza
        if (hasJumped)
        {
            hasJumped = false;
        }
    }
}


    
    void AlignToTerrainFixed()
    {
        // ‚≠ê FIX: Nueva implementaci√≥n que no afecta la rotaci√≥n Y
        
        // Detectar el terreno debajo
        Vector3 rayOrigin = transform.position + Vector3.up * 0.1f;
        RaycastHit hit;
        
        Vector3 targetNormal = Vector3.up;
        
        if (Physics.Raycast(rayOrigin, Vector3.down, out hit, 5f))
        {
            targetNormal = hit.normal;
            
            // Limitar el √°ngulo m√°ximo de inclinaci√≥n
            float angleFromUp = Vector3.Angle(Vector3.up, targetNormal);
            if (angleFromUp > maxTerrainTilt)
            {
                targetNormal = Vector3.Lerp(targetNormal, Vector3.up, 
                    (angleFromUp - maxTerrainTilt) / angleFromUp);
            }
        }
        
        // Suavizar la normal
        smoothNormal = Vector3.Slerp(smoothNormal, targetNormal, Time.deltaTime * terrainAlignmentSpeed);
        
        // ‚≠ê FIX: Calcular rotaci√≥n del terreno sin afectar Y
        // Crear una rotaci√≥n que alinee con el terreno pero mantenga el yaw actual
        Vector3 forward = Quaternion.Euler(0, currentYaw, 0) * Vector3.forward;
        Vector3 projectedForward = Vector3.ProjectOnPlane(forward, smoothNormal).normalized;
        
        if (projectedForward.magnitude > 0.1f)
        {
            // Crear quaternion que mira hacia adelante con la normal del terreno
            Quaternion targetTerrainRotation = Quaternion.LookRotation(projectedForward, smoothNormal);
            
            // ‚≠ê FIX: Extraer solo pitch y roll, manteniendo el yaw actual
            Vector3 terrainEuler = targetTerrainRotation.eulerAngles;
            terrainEuler.y = currentYaw; // Forzar el yaw a mantenerse
            
            // Aplicar la rotaci√≥n final
            Quaternion finalRotation = Quaternion.Euler(terrainEuler);
            transform.rotation = Quaternion.Slerp(transform.rotation, finalRotation, 
                Time.deltaTime * terrainAlignmentSpeed);
        }
    }

    // üåä Resetear rotaci√≥n a horizontal al nadar
    void ResetRotationToHorizontal()
    {
        // Crear rotaci√≥n horizontal (pitch=0, roll=0, mantener yaw)
        Vector3 targetEuler = transform.eulerAngles;
        targetEuler.x = 0f;  // Sin pitch (inclinaci√≥n adelante/atr√°s)
        targetEuler.z = 0f;  // Sin roll (inclinaci√≥n lateral)

        // Suavizar la transici√≥n a horizontal
        Quaternion targetRotation = Quaternion.Euler(targetEuler);
        transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation,
            Time.deltaTime * terrainAlignmentSpeed);

        // Tambi√©n resetear smoothNormal para que cuando salga del agua no tenga valores residuales
        smoothNormal = Vector3.Lerp(smoothNormal, Vector3.up, Time.deltaTime * terrainAlignmentSpeed);
    }

void UpdateAnimations()
{
    if (animator == null) return;

    // üåä PAR√ÅMETROS DE NATACI√ìN
    animator.SetBool("IsInWater", isInWater);
    animator.SetBool("IsSwimming", isSwimming);

    // üò¥ PAR√ÅMETROS DE SUE√ëO
    animator.SetBool("IsSleeping", isSleeping);
    animator.SetInteger("SleepState", (int)currentSleepState);

    // üçñ PAR√ÅMETROS DE COMIDA Y BEBIDA
    animator.SetBool("IsEating", isEating);
    animator.SetBool("IsDrinking", isDrinking);

    // üîπ 1. Velocidad normalizada (0 = quieto, 1 = corriendo/nadando)
    float normalizedSpeed = isInWater ? (currentSpeed / swimSpeed) : (currentSpeed / runSpeed);
    animator.SetFloat("Speed", normalizedSpeed);

    // üîπ 2. Estados principales
    animator.SetBool("IsGrounded", controller.isGrounded && !isInWater);
    animator.SetBool("IsRunning", isRunning && !isInWater);
    animator.SetBool("IsAttacking", isAttacking);
    animator.SetFloat("VerticalSpeed", velocity.y);

    // üîπ 3. Par√°metros de direcci√≥n (si los usas en tu blend tree)
    if (inputVector.magnitude > 0.1f)
    {
        Vector3 localMove = transform.InverseTransformDirection(currentMoveDirection);
        animator.SetFloat("MoveX", localMove.x);
        animator.SetFloat("MoveZ", localMove.z);
    }
    else
    {
        animator.SetFloat("MoveX", 0f);
        animator.SetFloat("MoveZ", 0f);
    }

    // üîπ 4. Par√°metros de c√°mara / mirada
    animator.SetFloat("Turn", currentTurn);
    animator.SetFloat("Look", currentLook);


}

    
    void UpdateCameraBasedTurnAndLook()
    {
        if (!enableStaticTurn || cameraTransform == null) 
        {
            currentTurn = Mathf.Lerp(currentTurn, 0f, Time.deltaTime * turnTransitionSpeed);
            currentLook = Mathf.Lerp(currentLook, 0f, Time.deltaTime * lookTransitionSpeed);
            return;
        }
        
        // Sistema de Turn basado en la diferencia entre c√°mara y dinosaurio
        Vector3 cameraForward = cameraTransform.forward;
        cameraForward.y = 0;
        cameraForward.Normalize();
        
        Vector3 dinoForward = transform.forward;
        dinoForward.y = 0;
        dinoForward.Normalize();
        
        float angleToCamera = Vector3.SignedAngle(dinoForward, cameraForward, Vector3.up);
        
        // Determinar el estado de Turn basado en el √°ngulo
        if (Mathf.Abs(angleToCamera) > turnDetectionThreshold)
        {
            if (angleToCamera > 0)
            {
                targetTurn = Mathf.Min(angleToCamera / 90f, maxTurnLookValue); // Girar a la derecha
                currentTurnState = TurnState.TurnRight;
            }
            else
            {
                targetTurn = Mathf.Max(angleToCamera / 90f, -maxTurnLookValue); // Girar a la izquierda
                currentTurnState = TurnState.TurnLeft;
            }
        }
        else
        {
            targetTurn = 0f;
            currentTurnState = TurnState.Idle;
        }
        
        // Sistema de Look (vertical)
        if (enableVerticalLook)
        {
            float cameraPitch = cameraTransform.eulerAngles.x;
            if (cameraPitch > 180f) cameraPitch -= 360f;
            
            if (Mathf.Abs(cameraPitch) > lookDetectionThreshold)
            {
                if (cameraPitch < 0) // Mirando hacia arriba
                {
                    targetLook = Mathf.Min(-cameraPitch / 45f, maxTurnLookValue);
                }
                else // Mirando hacia abajo
                {
                    targetLook = Mathf.Max(-cameraPitch / 45f, -maxTurnLookValue);
                }
            }
            else
            {
                targetLook = 0f;
            }
        }
        else
        {
            targetLook = 0f;
        }
        
        // Suavizar las transiciones
        currentTurn = Mathf.Lerp(currentTurn, targetTurn, Time.deltaTime * turnTransitionSpeed);
        currentLook = Mathf.Lerp(currentLook, targetLook, Time.deltaTime * lookTransitionSpeed);
        
        // Limitar valores m√°ximos
        currentTurn = Mathf.Clamp(currentTurn, -maxTurnLookValue, maxTurnLookValue);
        currentLook = Mathf.Clamp(currentLook, -maxTurnLookValue, maxTurnLookValue);
    }
    
    void UpdateAttackSystem()
    {
        // Detectar enemigos en rango
        DetectEnemiesInRange();
        
        // Procesar buffer de ataque
        if (enableAttackBuffer && attackBuffered)
        {
            attackBufferTimer -= Time.deltaTime;
            if (attackBufferTimer <= 0f)
            {
                attackBuffered = false;
            }
            
            // Intentar ejecutar el ataque buffereado
            if (attackCooldownTimer <= 0f && !isAttacking)
            {
                ExecuteAttack();
                attackBuffered = false;
            }
        }
        
        // Timer del ataque actual
        if (isAttacking)
        {
            attackTimer -= Time.deltaTime;
            if (attackTimer <= 0f)
            {
                EndAttack();
            }
        }
		
		if (isCalling)
	{
		callTimer -= Time.deltaTime;

		// Evitar ataque mientras ruge
		isAttacking = false;

		// Cuando termina el rugido
		if (callTimer <= 0f)
		{
			isCalling = false;
		}
	}
        
        // Cooldown
        if (attackCooldownTimer > 0f)
        {
            attackCooldownTimer -= Time.deltaTime;
        }
    }
    
    void DetectEnemiesInRange()
    {
        Vector3 attackPosition = attackPoint != null ? attackPoint.position : transform.position + transform.forward * 1f;
        Collider[] nearbyEnemies = Physics.OverlapSphere(attackPosition, attackRange * 1.5f, enemyLayer);
        
        enemiesInRange = 0;
        foreach (Collider enemy in nearbyEnemies)
        {
            Vector3 directionToEnemy = (enemy.transform.position - transform.position).normalized;
            float angleToEnemy = Vector3.Angle(transform.forward, directionToEnemy);
            
            if (angleToEnemy <= attackAngle / 2f)
            {
                float distanceToEnemy = Vector3.Distance(transform.position, enemy.transform.position);
                if (distanceToEnemy <= attackRange)
                {
                    enemiesInRange++;
                }
            }
        }
    }
    
    public void TryAttack()
    {
		if (isCalling) return;
		if (isSleeping) return; // üò¥ No atacar mientras duerme
		if (isEating) return; // üçñ No atacar mientras come
		if (isDrinking) return; // üíß No atacar mientras bebe

        // ‚úÖ Usar variable unificada lastGroundedTime
        bool canAttackNow = (controller.isGrounded || Time.time - lastGroundedTime < groundedTolerance || canAttackInAir)
                           && attackCooldownTimer <= 0f
                           && !isAttacking;

        if (canAttackNow)
        {
            ExecuteAttack();
        }
        else if (enableAttackBuffer)
        {
            attackBuffered = true;
            attackBufferTimer = attackBufferTime;
        }
    }
    
    void ExecuteAttack()
    {
        isAttacking = true;
        attackTimer = attackDuration;
        attackCooldownTimer = attackCooldown;
        currentState = MovementState.Attacking;
        
        // Limpiar lista de enemigos golpeados
        enemiesHit.Clear();
        
        // Animaci√≥n
        if (animator != null)
        {
            animator.SetTrigger("Attack");
        }
        
        // Sonido
        PlayAttackSound();
        
        // Hacer da√±o inmediatamente
        PerformAttackDamage();
    }
    
    void PerformAttackDamage()
    {
        Vector3 attackPosition = attackPoint != null ? attackPoint.position : transform.position + transform.forward * 1f;
        
        // Detectar enemigos en el √°rea de ataque
        Collider[] hitColliders = Physics.OverlapSphere(attackPosition, attackRange, enemyLayer);
        
        foreach (Collider hit in hitColliders)
        {
            if (enemiesHit.Contains(hit.gameObject))
                continue;
                
            Vector3 directionToTarget = (hit.transform.position - transform.position).normalized;
            float angleToTarget = Vector3.Angle(transform.forward, directionToTarget);
            
            if (angleToTarget <= attackAngle / 2f)
            {
                enemiesHit.Add(hit.gameObject);
                
                // Aplicar da√±o
                IDamageable damageable = hit.GetComponent<IDamageable>();
                if (damageable != null)
                {
                    damageable.TakeDamage(attackDamage);
                }
                
                // Aplicar knockback
                if (attackKnockback > 0f)
                {
                    Rigidbody rb = hit.GetComponent<Rigidbody>();
                    if (rb != null)
                    {
                        Vector3 knockbackDirection = directionToTarget;
                        knockbackDirection.y = 0.3f;
                        rb.AddForce(knockbackDirection.normalized * attackKnockback, ForceMode.Impulse);
                    }
                }
                
                // Sonido de impacto
                PlayHitSound();
            }
        }
    }
    
    void EndAttack()
    {
        isAttacking = false;
        enemiesHit.Clear();
        
        if (controller.isGrounded)
        {
            currentState = inputVector.magnitude > movementThreshold ? 
                (isRunning ? MovementState.Run : MovementState.Walk) : MovementState.Idle;
        }
    }
    
	public void TryJump()
	{
		if (isSleeping) return; // üò¥ No saltar mientras duerme
		if (isEating) return; // üçñ No saltar mientras come
		if (isDrinking) return; // üíß No saltar mientras bebe

		// ‚úÖ FIX: Usar lastGroundedTime con tolerancia para evitar timing issues
		// El bot√≥n ya est√° deshabilitado correctamente en la UI
		bool isGroundedRecently = (Time.time - lastGroundedTime) <= 0.2f;

		if (!isGroundedRecently && !controller.isGrounded)
		{
			return;
		}
		if (!canJump) return;
		if (isAttacking) return;

		// Ejecutar salto
		DoJump();
	}
	
private void DoJump()
{
    velocity.y = Mathf.Sqrt(Mathf.Max(0.0001f, jumpHeight) * -2f * gravity);
    canJump = false;
    hasJumped = true;
    jumpCooldownTimer = jumpCooldown;

    if (animator != null)
    {
        animator.ResetTrigger("Jump");
        animator.SetTrigger("Jump");
        animator.SetBool("IsGrounded", false);
        animator.SetFloat("VerticalSpeed", velocity.y);
    }

    PlayJumpSound();
}

// üò¥ SISTEMA DE SUE√ëO
public void ToggleSleep()
{
    // No permitir dormir si est√° en agua, atacando, saltando o en el aire
    if (isInWater || isAttacking || !controller.isGrounded)
        return;

    // üçñ No permitir dormir si est√° comiendo o bebiendo
    if (isEating || isDrinking)
        return;

    // Cambiar estado de sue√±o
    switch (currentSleepState)
    {
        case SleepState.Awake:
            // Iniciar transici√≥n a dormir
            currentSleepState = SleepState.EnteringSleep;
            currentState = MovementState.SleepEnter;
            sleepStateTimer = sleepEnterDuration;
            isSleeping = true;

            if (animator != null)
            {
                animator.SetTrigger("SleepEnter");
                animator.SetBool("IsSleeping", true);
            }

            Debug.Log("üò¥ Entrando a dormir...");
            break;

        case SleepState.Sleeping:
            // Despertar
            currentSleepState = SleepState.ExitingSleep;
            currentState = MovementState.SleepExit;
            sleepStateTimer = sleepExitDuration;

            if (animator != null)
            {
                animator.SetTrigger("SleepExit");
            }

            Debug.Log("üåÖ Despertando...");
            break;

        // No hacer nada si est√° en transici√≥n
        case SleepState.EnteringSleep:
        case SleepState.ExitingSleep:
            break;
    }
}

private void UpdateSleepSystem()
{
    if (currentSleepState == SleepState.Awake)
        return;

    // Actualizar timer de transici√≥n
    if (sleepStateTimer > 0f)
    {
        sleepStateTimer -= Time.deltaTime;

        if (sleepStateTimer <= 0f)
        {
            // Transici√≥n completada
            switch (currentSleepState)
            {
                case SleepState.EnteringSleep:
                    // Transici√≥n completa, ahora est√° completamente dormido
                    currentSleepState = SleepState.Sleeping;
                    currentState = MovementState.Sleeping;
                    Debug.Log("üí§ Durmiendo profundamente...");
                    break;

                case SleepState.ExitingSleep:
                    // Transici√≥n completa, ahora est√° despierto
                    currentSleepState = SleepState.Awake;
                    isSleeping = false;

                    if (animator != null)
                    {
                        animator.SetBool("IsSleeping", false);
                    }

                    Debug.Log("‚úÖ Completamente despierto!");
                    break;
            }
        }
    }
}



void UpdateTimers()
{
    // ‚úÖ Control del cooldown de salto - SIMPLIFICADO
    if (jumpCooldownTimer > 0f)
    {
        jumpCooldownTimer -= Time.deltaTime;

        // Cuando el cooldown termina, permitir saltar de nuevo
        if (jumpCooldownTimer <= 0f)
        {
            jumpCooldownTimer = 0f;
            canJump = true;  // ‚úÖ Resetear aqu√≠ cuando el cooldown termine
        }
    }

    // Control del cooldown del ataque
    if (attackCooldownTimer > 0f)
    {
        attackCooldownTimer -= Time.deltaTime;
    }

    // Control del buffer de ataque (si lo tienes activo)
    if (enableAttackBuffer && attackBuffered)
    {
        attackBufferTimer -= Time.deltaTime;
        if (attackBufferTimer <= 0f)
        {
            attackBuffered = false;
        }
    }
}

    
    void UpdateState()
    {
        // üò¥ Estados de sue√±o tienen m√°xima prioridad
        if (isSleeping)
        {
            // El estado ya est√° configurado en ToggleSleep() y UpdateSleepSystem()
            // No cambiar el estado mientras est√° durmiendo
            return;
        }

        // üçñ Estados de comer y beber tienen alta prioridad
        if (isEating)
        {
            currentState = MovementState.Eating;
            return;
        }

        if (isDrinking)
        {
            currentState = MovementState.Drinking;
            return;
        }

        // üåä Estados de nataci√≥n tienen prioridad
        if (isInWater)
        {
            if (isSwimming && currentSpeed > movementThreshold)
            {
                currentState = MovementState.Swimming;
            }
            else
            {
                currentState = MovementState.IdleSwim;
            }
        }
        else if (isAttacking)
        {
            currentState = MovementState.Attacking;
        }
        else if (!controller.isGrounded)
        {
            currentState = velocity.y > 0 ? MovementState.Jump : MovementState.Falling;
        }
        else if (currentSpeed > movementThreshold)
        {
            currentState = isRunning ? MovementState.Run : MovementState.Walk;
        }
        else
        {
            currentState = MovementState.Idle;
        }
    }
    
    void UpdateUI()
    {
        // üçñ Deshabilitar todos los botones (excepto eat/drink) si est√° comiendo o bebiendo
        bool isPerformingAction = isEating || isDrinking;

        if (runButton != null)
        {
            runButton.interactable = !isPerformingAction;
            ColorBlock colors = runButton.colors;
            colors.normalColor = isRunning ? Color.green : Color.white;
            runButton.colors = colors;
        }

        // ‚úÖ DESHABILITAR BOT√ìN DE SALTO cuando no se puede usar
        if (jumpButton != null)
        {
            bool canJumpNow = controller.isGrounded && canJump && !isAttacking && !isPerformingAction;
            jumpButton.interactable = canJumpNow;

            // Cambiar color visual para feedback
            ColorBlock colors = jumpButton.colors;
            colors.normalColor = canJumpNow ? Color.white : Color.gray;
            jumpButton.colors = colors;
        }

        if (attackButton != null)
        {
            attackButton.interactable = !isPerformingAction;
            ColorBlock colors = attackButton.colors;
            if (isAttacking)
                colors.normalColor = Color.red;
            else if (attackCooldownTimer > 0)
                colors.normalColor = Color.gray;
            else if (enemiesInRange > 0)
                colors.normalColor = Color.yellow;
            else
                colors.normalColor = Color.white;
            attackButton.colors = colors;
        }

        if (callButton != null)
        {
            callButton.interactable = !isPerformingAction;
        }

        // üò¥ Sleep button UI
        if (sleepButton != null)
        {
            // Deshabilitar si est√° en agua, atacando, en el aire, o comiendo/bebiendo
            bool canSleep = !isInWater && !isAttacking && controller.isGrounded && !isPerformingAction;
            sleepButton.interactable = canSleep;

            ColorBlock colors = sleepButton.colors;

            // Cambiar color seg√∫n el estado
            if (currentSleepState == SleepState.Sleeping)
            {
                colors.normalColor = Color.cyan; // Azul cuando est√° durmiendo
            }
            else if (currentSleepState == SleepState.EnteringSleep)
            {
                colors.normalColor = Color.blue; // Azul oscuro cuando est√° entrando a dormir
            }
            else if (currentSleepState == SleepState.ExitingSleep)
            {
                colors.normalColor = Color.yellow; // Amarillo cuando est√° despertando
            }
            else if (canSleep)
            {
                colors.normalColor = Color.white; // Blanco cuando puede dormir
            }
            else
            {
                colors.normalColor = Color.gray; // Gris cuando no puede dormir
            }

            sleepButton.colors = colors;
        }

        // üçñ Eat button UI
        if (eatButton != null && isFoodInRange)
        {
            ColorBlock colors = eatButton.colors;
            if (isEating)
                colors.normalColor = Color.green; // Verde cuando est√° comiendo
            else if (hunger <= 0f)
                colors.normalColor = Color.gray; // Gris si no tiene hambre
            else
                colors.normalColor = Color.white; // Blanco cuando puede comer
            eatButton.colors = colors;
        }

        // üíß Drink button UI
        if (drinkButton != null && isWaterSourceInRange)
        {
            ColorBlock colors = drinkButton.colors;
            if (isDrinking)
                colors.normalColor = Color.cyan; // Cyan cuando est√° bebiendo
            else if (thirst <= 0f)
                colors.normalColor = Color.gray; // Gris si no tiene sed
            else
                colors.normalColor = Color.white; // Blanco cuando puede beber
            drinkButton.colors = colors;
        }
    }
    
    // M√©todos de audio
	void PlayCallSound()
	{
		// Si ya est√° rugiendo o atacando, no permitir otro rugido
		if (isCalling || isAttacking) return;
		if (isSleeping) return; // üò¥ No rugir mientras duerme
		if (isEating) return; // üçñ No rugir mientras come
		if (isDrinking) return; // üíß No rugir mientras bebe

		// Activar rugido
		isCalling = true;
		callTimer = callDuration;

		// Sonido de rugido
		if (audioSource != null && callSounds.Length > 0)
		{
			AudioClip clip = callSounds[Random.Range(0, callSounds.Length)];
			audioSource.PlayOneShot(clip);
		}

		// Animaci√≥n
		if (animator != null)
		{
			animator.ResetTrigger("Attack");
			animator.SetTrigger("Call");
			animator.SetBool("IsAttacking", false);
		}
	}

    
    void PlayJumpSound()
    {
        if (audioSource != null && jumpSounds.Length > 0)
        {
            AudioClip clip = jumpSounds[Random.Range(0, jumpSounds.Length)];
            audioSource.PlayOneShot(clip);
        }
    }
    
    void PlayAttackSound()
    {
        if (audioSource != null && attackSounds.Length > 0)
        {
            AudioClip clip = attackSounds[Random.Range(0, attackSounds.Length)];
            audioSource.PlayOneShot(clip);
        }
    }
    
    void PlayHitSound()
    {
        if (audioSource != null && hitSounds.Length > 0)
        {
            AudioClip clip = hitSounds[Random.Range(0, hitSounds.Length)];
            audioSource.PlayOneShot(clip);
        }
    }
    
    // M√©todos de pasos (llamados por eventos de animaci√≥n)
    public void PlayFootstep()
    {
        if (audioSource != null)
        {
            AudioClip[] clips = isRunning ? runSounds : walkSounds;
            if (clips.Length > 0)
            {
                AudioClip clip = clips[Random.Range(0, clips.Length)];
                audioSource.PlayOneShot(clip, 0.7f);
            }
        }
    }
    
    public void PlayLandSound()
    {
        if (audioSource != null && landSounds.Length > 0)
        {
            AudioClip clip = landSounds[Random.Range(0, landSounds.Length)];
            audioSource.PlayOneShot(clip);
        }
    }
    
    void OnDrawGizmosSelected()
    {
        if (!showAttackGizmos) return;
        
        Vector3 attackPosition = attackPoint != null ? attackPoint.position : transform.position + transform.forward * 1f;
        
        // Gizmos de ataque
        Gizmos.color = isAttacking ? Color.red : (enemiesInRange > 0 ? Color.yellow : Color.cyan);
        Gizmos.DrawWireSphere(attackPosition, attackRange);
        
        if (Application.isPlaying)
        {
            Gizmos.color = Color.red;
            Vector3 forward = transform.forward;
            Vector3 right = Quaternion.Euler(0, attackAngle / 2f, 0) * forward;
            Vector3 left = Quaternion.Euler(0, -attackAngle / 2f, 0) * forward;
            
            Gizmos.DrawLine(transform.position, transform.position + right * attackRange);
            Gizmos.DrawLine(transform.position, transform.position + left * attackRange);
        }
        
        // Gizmos de ground detection
        if (Application.isPlaying)
        {
            Vector3 rayStart = transform.position + Vector3.up * 0.5f;
            Gizmos.color = controller != null && controller.isGrounded ? Color.green : Color.red;
            Gizmos.DrawLine(rayStart, rayStart + Vector3.down * 2f);
            
            if (isOnSlope)
            {
                Gizmos.color = Color.yellow;
                Gizmos.DrawLine(slopeHit.point, slopeHit.point + slopeHit.normal * 2f);
            }
            
            // Gizmos de alineaci√≥n con terreno
            if (alignToTerrain)
            {
                // Mostrar normal suavizada del terreno
                Gizmos.color = Color.magenta;
                Gizmos.DrawLine(transform.position, transform.position + smoothNormal * 3f);
                
                // Mostrar up vector del transform
                Gizmos.color = Color.cyan;
                Gizmos.DrawLine(transform.position, transform.position + transform.up * 2.5f);
            }
        }
        
        // Gizmos de direcci√≥n de movimiento
        if (Application.isPlaying && currentMoveDirection != Vector3.zero)
        {
            // Direcci√≥n actual
            Gizmos.color = Color.green;
            Gizmos.DrawLine(transform.position + Vector3.up * 0.5f, 
                           transform.position + Vector3.up * 0.5f + currentMoveDirection * 2f);
            
            // Direcci√≥n objetivo
            if (targetMoveDirection != Vector3.zero)
            {
                Gizmos.color = Color.yellow;
                Gizmos.DrawLine(transform.position + Vector3.up * 0.7f, 
                               transform.position + Vector3.up * 0.7f + targetMoveDirection * 2f);
            }
        }

        // üåä Gizmos de agua
        if (Application.isPlaying && isInWater && waterCollider != null)
        {
            Gizmos.color = Color.cyan;
            Gizmos.DrawWireSphere(transform.position, 1f);

            // L√≠nea de superficie del agua
            Gizmos.color = Color.blue;
            Vector3 surfacePos = new Vector3(transform.position.x, waterSurfaceY, transform.position.z);
            Gizmos.DrawLine(surfacePos + Vector3.left * 2f, surfacePos + Vector3.right * 2f);
            Gizmos.DrawLine(surfacePos + Vector3.forward * 2f, surfacePos + Vector3.back * 2f);
        }
    }

    // üçñ SISTEMA DE NECESIDADES
    void UpdateNeedsSystem()
    {
        // Incrementar hambre y sed con el tiempo
        hunger = Mathf.Clamp(hunger + hungerIncreaseRate * Time.deltaTime, 0f, 100f);
        thirst = Mathf.Clamp(thirst + thirstIncreaseRate * Time.deltaTime, 0f, 100f);

        // Sistema de estamina
        if (isRunning && currentSpeed > movementThreshold && !isInWater)
        {
            // ‚ö° Gastar estamina al correr
            stamina = Mathf.Clamp(stamina - staminaDrainRate * Time.deltaTime, 0f, 100f);
        }
        else if (isSleeping)
        {
            // üò¥ Regenerar estamina m√°s r√°pido al dormir
            stamina = Mathf.Clamp(stamina + staminaRegenRate * staminaRegenMultiplierWhenSleeping * Time.deltaTime, 0f, 100f);
        }
        else if (currentSpeed <= movementThreshold && !isAttacking && !isEating && !isDrinking)
        {
            // üîÑ Regenerar estamina cuando est√° quieto
            stamina = Mathf.Clamp(stamina + staminaRegenRate * Time.deltaTime, 0f, 100f);
        }

        // Actualizar par√°metros del Animator
        if (animator != null)
        {
            animator.SetFloat("Hunger", hunger);
            animator.SetFloat("Thirst", thirst);
            animator.SetFloat("Stamina", stamina);
        }
    }

    // üçñ DETECCI√ìN DE COMIDA Y AGUA
    void DetectFoodAndWater()
    {
        // Detectar comida cercana
        GameObject[] foodObjects = GameObject.FindGameObjectsWithTag(foodTag);
        nearestFood = null;
        float closestFoodDistance = foodDetectionRange;

        foreach (GameObject food in foodObjects)
        {
            float distance = Vector3.Distance(transform.position, food.transform.position);
            if (distance < closestFoodDistance)
            {
                closestFoodDistance = distance;
                nearestFood = food;
            }
        }

        isFoodInRange = nearestFood != null;

        // Detectar agua potable cercana
        GameObject[] waterObjects = GameObject.FindGameObjectsWithTag(drinkableWaterTag);
        nearestWaterSource = null;
        float closestWaterDistance = waterDetectionRange;

        foreach (GameObject water in waterObjects)
        {
            float distance = Vector3.Distance(transform.position, water.transform.position);
            if (distance < closestWaterDistance)
            {
                closestWaterDistance = distance;
                nearestWaterSource = water;
            }
        }

        isWaterSourceInRange = nearestWaterSource != null;

        // Mostrar/ocultar botones seg√∫n disponibilidad
        if (eatButton != null)
        {
            eatButton.gameObject.SetActive(isFoodInRange);
        }

        if (drinkButton != null)
        {
            drinkButton.gameObject.SetActive(isWaterSourceInRange);
        }
    }

    // üçñ TOGGLE COMER
    public void ToggleEating()
    {
        if (isEating)
        {
            // Dejar de comer
            StopEating();
        }
        else
        {
            // Empezar a comer (solo si hay comida cerca)
            if (isFoodInRange && nearestFood != null)
            {
                StartEating();
            }
        }
    }

    void StartEating()
    {
        // No puede comer si est√° haciendo otras acciones
        if (isAttacking || isSleeping || isDrinking || isCalling)
            return;

        // No tiene sentido comer si no tiene hambre
        if (hunger <= 0f)
            return;

        isEating = true;
        currentState = MovementState.Eating;

        // Activar animaci√≥n de comer
        if (animator != null)
        {
            animator.SetBool("IsEating", true);
            animator.SetTrigger("Eat");
        }

        Debug.Log("üçñ Dinosaurio comenz√≥ a comer");
    }

    void StopEating()
    {
        isEating = false;

        // Desactivar animaci√≥n de comer
        if (animator != null)
        {
            animator.SetBool("IsEating", false);
        }

        Debug.Log("üçñ Dinosaurio dej√≥ de comer");
    }

    void UpdateEatingSystem()
    {
        if (!isEating) return;

        // Reducir hambre gradualmente mientras come
        if (hunger > 0f)
        {
            hunger = Mathf.Clamp(hunger - hungerDecreaseRateWhileEating * Time.deltaTime, 0f, 100f);
        }
        else
        {
            // Si ya no tiene hambre, dejar de comer autom√°ticamente
            StopEating();
            Debug.Log("üçñ Dinosaurio est√° lleno!");
        }

        // Si la comida se alej√≥ o desapareci√≥, dejar de comer
        if (!isFoodInRange || nearestFood == null)
        {
            StopEating();
            Debug.Log("üçñ La comida ya no est√° disponible");
        }
    }

    // üíß TOGGLE BEBER
    public void ToggleDrinking()
    {
        if (isDrinking)
        {
            // Dejar de beber
            StopDrinking();
        }
        else
        {
            // Empezar a beber (solo si hay agua cerca)
            if (isWaterSourceInRange && nearestWaterSource != null)
            {
                StartDrinking();
            }
        }
    }

    void StartDrinking()
    {
        // No puede beber si est√° haciendo otras acciones
        if (isAttacking || isSleeping || isEating || isCalling)
            return;

        // No tiene sentido beber si no tiene sed
        if (thirst <= 0f)
            return;

        isDrinking = true;
        currentState = MovementState.Drinking;

        // Activar animaci√≥n de beber
        if (animator != null)
        {
            animator.SetBool("IsDrinking", true);
            animator.SetTrigger("Drink");
        }

        Debug.Log("üíß Dinosaurio comenz√≥ a beber");
    }

    void StopDrinking()
    {
        isDrinking = false;

        // Desactivar animaci√≥n de beber
        if (animator != null)
        {
            animator.SetBool("IsDrinking", false);
        }

        Debug.Log("üíß Dinosaurio dej√≥ de beber");
    }

    void UpdateDrinkingSystem()
    {
        if (!isDrinking) return;

        // Reducir sed gradualmente mientras bebe
        if (thirst > 0f)
        {
            thirst = Mathf.Clamp(thirst - thirstDecreaseRateWhileDrinking * Time.deltaTime, 0f, 100f);
        }
        else
        {
            // Si ya no tiene sed, dejar de beber autom√°ticamente
            StopDrinking();
            Debug.Log("üíß Dinosaurio est√° hidratado!");
        }

        // Si el agua se alej√≥ o desapareci√≥, dejar de beber
        if (!isWaterSourceInRange || nearestWaterSource == null)
        {
            StopDrinking();
            Debug.Log("üíß El agua ya no est√° disponible");
        }
    }

    // üåä SISTEMA DE DETECCI√ìN DE AGUA
    void OnTriggerEnter(Collider other)
    {
        // Verificar si el collider est√° en el layer de agua
        if (((1 << other.gameObject.layer) & waterLayer) != 0)
        {
            // Guardar referencia al collider del agua
            waterCollider = other;
            UpdateWaterSurface(other);

            // ‚úÖ NO activar isInWater inmediatamente, esperar a verificar profundidad
            Debug.Log("üåä Dinosaurio toc√≥ el agua (verificando profundidad...)");
        }
    }

    void OnTriggerStay(Collider other)
    {
        // Verificar si el collider est√° en el layer de agua
        if (((1 << other.gameObject.layer) & waterLayer) != 0)
        {
            // Actualizar altura de superficie del agua
            UpdateWaterSurface(other);

            // ‚úÖ Calcular profundidad del agua
            float waterDepth = waterSurfaceY - transform.position.y;

            // üîÑ HIST√âRESIS: Usar diferentes umbrales para entrar/salir
            // Esto evita el parpadeo cuando el dinosaurio flota
            float enterThreshold = waterSurfaceOffset;
            float exitThreshold = waterSurfaceOffset * waterHysteresis;

            // ‚úÖ Solo activar isInWater si est√° lo suficientemente profundo
            if (!isInWater && waterDepth >= enterThreshold)
            {
                // Entr√≥ a agua profunda
                isInWater = true;
                wasInWater = true;
                Debug.Log($"üèä Agua profunda detectada! (profundidad: {waterDepth:F2}m, umbral: {enterThreshold:F2}m)");
            }
            // ‚úÖ Solo desactivar si la profundidad baja significativamente (hist√©resis)
            else if (isInWater && waterDepth < exitThreshold)
            {
                // Sali√≥ a agua poco profunda (con tolerancia)
                isInWater = false;
                isSwimming = false;
                Debug.Log($"üö∂ Agua poco profunda (profundidad: {waterDepth:F2}m, umbral salida: {exitThreshold:F2}m)");
            }
        }
    }

    void OnTriggerExit(Collider other)
    {
        // Verificar si el collider est√° en el layer de agua
        if (((1 << other.gameObject.layer) & waterLayer) != 0)
        {
            ExitWater();
        }
    }

    void UpdateWaterSurface(Collider water)
    {
        // Calcular la superficie del agua (parte superior del collider)
        Bounds bounds = water.bounds;
        waterSurfaceY = bounds.max.y;
    }

    void ExitWater()
    {
        isInWater = false;
        isSwimming = false;
        waterCollider = null;

        Debug.Log("üèñÔ∏è Dinosaurio sali√≥ del agua!");
    }
}

// Interface para objetos que pueden recibir da√±o
public interface IDamageable
{
    void TakeDamage(float damage);
}
