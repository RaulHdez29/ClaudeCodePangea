using UnityEngine;
using UnityEngine.UI;
using System.Collections.Generic;

// VERSIÃ“N CORREGIDA - FIX PARA PROBLEMA DE JOYSTICK
// âœ… SeparaciÃ³n correcta de rotaciÃ³n horizontal y alineaciÃ³n con terreno
// âœ… Sin conflictos de direcciÃ³n al girar
// âœ… Movimiento suave y predecible

public class SimpleDinosaurController : MonoBehaviour
{
    [Header("Referencias")]
    public Animator animator;
    public AudioSource audioSource;
    public Transform cameraTransform;
    
    [Header("Controles TÃ¡ctiles")]
    public VariableJoystick movementJoystick;
    public Button runButton;
    public Button crouchButton;
    public Button callButton;
    public Button jumpButton;
    public Button attackButton;

    [Header("ğŸ“ CONFIGURACIÃ“N DE TAMAÃ‘O DEL DINOSAURIO")]
    [Tooltip("Selecciona el tamaÃ±o del dinosaurio para aplicar valores preconfigurados")]
    public DinosaurSize dinosaurSize = DinosaurSize.Medium;
    [Tooltip("Altura real del modelo (usado para cÃ¡lculos automÃ¡ticos)")]
    public float modelHeight = 2.5f;
    [Space(10)]
    [Tooltip("Haz click derecho en el script â†’ 'Apply Size Preset' para aplicar configuraciÃ³n automÃ¡tica")]
    public bool autoConfigureOnStart = false;

    public enum DinosaurSize
    {
        Small,      // 1-2m (Compsognathus, Velociraptor joven)
        Medium,     // 3-5m (Velociraptor, Dilophosaurus)
        Large,      // 6-10m (T-Rex, Spinosaurus)
        Custom      // Valores manuales 
    }

    [Header("Velocidades")]
    public float walkSpeed = 2f;
    public float runSpeed = 5f;
    public float crouchSpeed = 1f;
    public float turnSpeed = 120f;
    
    [Header("ğŸ”„ CONFIGURACIÃ“N DE RADIO DE GIRO - MEJORADO")]
    [Tooltip("Radio mÃ­nimo de giro al caminar")]
    public float walkTurnRadius = 1.5f;
    [Tooltip("Radio mÃ­nimo de giro al correr")]
    public float runTurnRadius = 3f;
    [Tooltip("Radio mÃ­nimo de giro en crouch")]
    public float crouchTurnRadius = 1.2f;
    [Tooltip("Suavizado del giro (mÃ¡s alto = mÃ¡s suave)")]
    [Range(1f, 10f)]
    public float turnSmoothness = 5f;
    [Tooltip("Velocidad mÃ¡xima de rotaciÃ³n (grados/segundo)")]
    public float maxRotationSpeed = 180f;
    [Tooltip("Factor de suavizado de direcciÃ³n")]
    [Range(0.1f, 1f)]
    public float directionSmoothFactor = 0.3f;
    [Tooltip("Tolerancia para considerar que el dinosaurio estÃ¡ mirando hacia el objetivo")]
    [Range(5f, 45f)]
    public float lookAtTolerance = 15f;
    [Tooltip("Factor de velocidad durante el giro (reduce velocidad al girar)")]
    [Range(0.3f, 1f)]
    public float turningSpeedFactor = 0.7f;
    
    [Header("â­ CONFIGURACIÃ“N DE SALTO")]
    [Tooltip("Altura del salto")]
    public float jumpHeight = 2f;
    [Tooltip("Tiempo de espera entre saltos (despuÃ©s de aterrizar)")]
    public float jumpCooldown = 1f;
	
	[Header("â­ SALTO - Coyote & Buffer")]
	[Tooltip("Tiempo (s) que permitido saltar despuÃ©s de despegar (coyote time)")]
	public float coyoteTime = 0.12f;
	[Tooltip("Tiempo (s) para guardar input de salto antes de aterrizar (jump buffer)")]
	public float jumpBufferTime = 0.12f;

	private float lastGroundedTime = -10f;  // âœ… Variable unificada
	private float jumpBufferTimerLocal = 0f;
    
    [Header("â­ CONFIGURACIÃ“N DE GRAVEDAD")]
    [Tooltip("Fuerza de gravedad (mÃ¡s negativo = cae mÃ¡s rÃ¡pido)")]
    public float gravity = -20f;
    [Tooltip("Velocidad terminal de caÃ­da")]
    public float terminalVelocity = -50f;
    
    [Header("ğŸ”ï¸ CONFIGURACIÃ“N DE PENDIENTES")]
    [Tooltip("Multiplicador de velocidad en subidas (mayor = sube mÃ¡s rÃ¡pido)")]
    [Range(0.5f, 2f)]
    public float slopeSpeedMultiplier = 1.2f;
    [Tooltip("Fuerza extra al bajar pendientes")]
    public float slopeForceDown = 10f;
    [Tooltip("â­ Alinear modelo con el terreno")]
    public bool alignToTerrain = true;
    [Tooltip("Velocidad de alineaciÃ³n con el terreno")]
    [Range(1f, 20f)]
    public float terrainAlignmentSpeed = 8f;
    [Tooltip("MÃ¡ximo Ã¡ngulo de inclinaciÃ³n permitido")]
    [Range(0f, 90f)]
    public float maxTerrainTilt = 45f;
    
    [Header("âš”ï¸ SISTEMA DE ATAQUE - MEJORADO")]
    [Tooltip("DaÃ±o que hace cada ataque")]
    public float attackDamage = 25f;
    [Tooltip("Rango del ataque (distancia)")]
    public float attackRange = 2f;
    [Tooltip("Ãngulo del ataque (cono frontal)")]
    [Range(0f, 180f)]
    public float attackAngle = 90f;
    [Tooltip("â­ Tiempo de espera entre ataques - REDUCIDO para mejor respuesta")]
    public float attackCooldown = 0.5f;
    [Tooltip("DuraciÃ³n del ataque (animaciÃ³n)")]
    public float attackDuration = 0.5f;
    [Tooltip("Layer de enemigos (objetos que pueden recibir daÃ±o)")]
    public LayerMask enemyLayer;
    [Tooltip("Punto desde donde sale el ataque (boca del dinosaurio)")]
    public Transform attackPoint;
    [Tooltip("Mostrar Ã¡rea de ataque en el editor")]
    public bool showAttackGizmos = true;
    
    [Header("âš”ï¸ NUEVAS MEJORAS DE ATAQUE")]
    [Tooltip("â­ Permitir buffer de input (guarda el ataque para despuÃ©s)")]
    public bool enableAttackBuffer = true;
    [Tooltip("â­ Tiempo que se guarda el input de ataque")]
    public float attackBufferTime = 0.3f;
    [Tooltip("â­ Tolerancia al estar 'en el suelo' para atacar")]
    public float groundedTolerance = 0.2f;
    [Tooltip("â­ Permitir atacar en el aire")]
    public bool canAttackInAir = true;
    
    [Header("âš”ï¸ EFECTOS DE ATAQUE")]
    [Tooltip("Fuerza de empuje al atacar")]
    public float attackKnockback = 5f;
    [Tooltip("Puede moverse mientras ataca")]
    public bool canMoveWhileAttacking = false;
    [Tooltip("Puede rotar mientras ataca")]
    public bool canRotateWhileAttacking = true;
    
    [Header("ğŸµ AUDIO DE ATAQUE")]
    public AudioClip[] attackSounds;
    public AudioClip[] hitSounds;
	
	[Header("ğŸ¤ Call / Roar Settings")]
	[Tooltip("DuraciÃ³n del rugido (segundos) - DEPRECATED: Usa CallSystem en su lugar")]
	public float callDuration = 2.5f; // ajusta segÃºn la duraciÃ³n de tu animaciÃ³n
	private bool isCalling = false;
	private float callTimer = 0f;

	[Header("ğŸ“ Sistema de Llamados Mejorado")]
	[Tooltip("Referencia al sistema de llamados (CallSystem) - opcional")]
	public CallSystem callSystem;

	[Header("ğŸ– Sistema de Hambre, Sed y Estamina")]
	[Tooltip("Hambre mÃ¡xima")]
	[Range(0f, 200f)]
	public float maxHunger = 100f;
	[Tooltip("Hambre actual")]
	public float currentHunger = 100f;
	[Tooltip("Velocidad de degradaciÃ³n de hambre por segundo")]
	public float hungerDecayRate = 0.5f;

	[Tooltip("Sed mÃ¡xima")]
	[Range(0f, 200f)]
	public float maxThirst = 100f;
	[Tooltip("Sed actual")]
	public float currentThirst = 100f;
	[Tooltip("Velocidad de degradaciÃ³n de sed por segundo")]
	public float thirstDecayRate = 0.7f;

	[Tooltip("Estamina mÃ¡xima")]
	[Range(0f, 200f)]
	public float maxStamina = 100f;
	[Tooltip("Estamina actual")]
	public float currentStamina = 100f;
	[Tooltip("Velocidad de consumo de estamina al correr")]
	public float staminaDrainRate = 10f;
	[Tooltip("Velocidad de regeneraciÃ³n de estamina normal")]
	public float staminaRegenRate = 5f;
	[Tooltip("Velocidad de regeneraciÃ³n de estamina al dormir")]
	public float staminaSleepRegenRate = 15f;

	[Header("ğŸ— Sistema de Comer/Beber")]
	[Tooltip("Distancia para detectar comida/agua")]
	public float foodDetectionRange = 3f;
	[Tooltip("Velocidad de aumento de hambre al comer")]
	public float eatingSpeed = 15f;
	[Tooltip("Velocidad de aumento de sed al beber")]
	public float drinkingSpeed = 20f;
	[Tooltip("DuraciÃ³n de animaciÃ³n de comer")]
	public float eatingAnimationDuration = 2f;

	[Header("ğŸ– UI de Comer/Beber")]
	[Tooltip("BotÃ³n para comer (aparece cerca de comida)")]
	public Button eatButton;
	[Tooltip("BotÃ³n para beber (aparece cerca de agua)")]
	public Button drinkButton;

	[Header("ğŸ“Š Barras UI de EstadÃ­sticas")]
	[Tooltip("Barra de hambre (Image tipo Filled)")]
	public Image hungerBar;
	[Tooltip("Barra de sed (Image tipo Filled)")]
	public Image thirstBar;
	[Tooltip("Barra de estamina (Image tipo Filled)")]
	public Image staminaBar;

	// Estados de comer/beber
	private bool isEating = false;
	private bool isDrinking = false;
	private GameObject nearbyFood = null;
	private GameObject nearbyWater = null;

	// Referencia cacheada al sistema de sueÃ±o
	private DinosaurSleepSystem sleepSystemCache;

    [Header("ğŸ”„ CONFIGURACIÃ“N DE TURN Y LOOK - BASADO EN CÃMARA")]
    [Tooltip("Activar poses estÃ¡ticas de giro")]
    public bool enableStaticTurn = true;
    [Tooltip("Activar poses de mirada arriba/abajo")]
    public bool enableVerticalLook = true;
    [Tooltip("Umbral para detectar cambio de cÃ¡mara (grados)")]
    public float turnDetectionThreshold = 30f;
    [Tooltip("Umbral para detectar cambio de cÃ¡mara vertical (grados)")]
    public float lookDetectionThreshold = 20f;
    [Tooltip("Ãngulo para detectar frente/atrÃ¡s")]
    public float frontBackAngle = 45f;
    [Tooltip("Velocidad de transiciÃ³n entre poses de giro")]
    [Range(1f, 10f)]
    public float turnTransitionSpeed = 4f;
    [Tooltip("Velocidad de transiciÃ³n entre poses de mirada vertical")]
    [Range(1f, 10f)]
    public float lookTransitionSpeed = 4f;
    [Tooltip("â­ LÃ­mite mÃ¡ximo de Turn y Look (evita poses estÃ¡ticas)")]
    [Range(0.5f, 1f)]
    public float maxTurnLookValue = 0.80f;

    [Header("ğŸ­ SISTEMA DE IDLE VARIATIONS")]
    [Tooltip("Activar cambio automÃ¡tico entre diferentes idles")]
    public bool enableIdleVariations = true;
    [Tooltip("NÃºmero de idle variations disponibles (0 = idle normal, 1+ = variations)")]
    [Range(0, 10)]
    public int numberOfIdleVariations = 3;
    [Tooltip("Tiempo mÃ­nimo en idle antes de cambiar (segundos)")]
    public float minIdleTimeBeforeVariation = 5f;
    [Tooltip("Tiempo mÃ¡ximo en idle antes de cambiar (segundos)")]
    public float maxIdleTimeBeforeVariation = 15f;
    [Tooltip("Probabilidad de activar idle variation (0-100%)")]
    [Range(0f, 100f)]
    public float idleVariationChance = 70f;
    [Tooltip("DuraciÃ³n de cada idle variation (segundos)")]
    public float idleVariationDuration = 3f;
    [Tooltip("Permitir idle variations solo cuando completamente quieto")]
    public bool onlyWhenFullyIdle = true;
    
    [Header("ConfiguraciÃ³n de Movimiento")]
    public float turnInPlaceThreshold = 0.1f;
    public float movementThreshold = 0.2f;
    [Tooltip("Suavizado del movimiento")]
    [Range(1f, 20f)]
    public float movementSmoothness = 10f;
    [Tooltip("Suavizado de las animaciones de direcciÃ³n (MoveX/MoveZ)")]
    [Range(0.05f, 0.5f)]
    public float directionAnimationDampTime = 0.1f;
    
    [Header("Audio")]
    public AudioClip[] walkSounds;
    public AudioClip[] runSounds;
    public AudioClip[] crouchWalkSounds;
    public AudioClip[] callSounds;
    public AudioClip[] jumpSounds;
    public AudioClip[] landSounds;

    [Header("ğŸŒŠ SISTEMA DE NATACIÃ“N")]
    [Tooltip("Layer del agua (debe tener Trigger activado)")]
    public LayerMask waterLayer;
    [Tooltip("Velocidad de nataciÃ³n")]
    public float swimSpeed = 3f;
    [Tooltip("Fuerza de flotaciÃ³n (empuje hacia arriba)")]
    public float buoyancyForce = 9.8f;
    [Tooltip("Resistencia del agua (frena movimiento)")]
    [Range(0.5f, 0.95f)]
    public float waterDrag = 0.8f;
    [Tooltip("Altura del agua donde empieza a flotar")]
    public float waterSurfaceOffset = 1f;
    [Tooltip("Tolerancia para evitar parpadeo entre estados (0.5 = 50% del offset)")]
    [Range(0.3f, 0.8f)]
    public float waterHysteresis = 0.6f;
    [Tooltip("Permitir salto desde el agua")]
    public bool canJumpFromWater = false;

    // Estados
    public enum MovementState
    {
        Idle = 0,
        Walk = 1,
        Run = 2,
        Crouch = 3,
        Jump = 4,
        Falling = 5,
        Attacking = 6,
        Swimming = 7,
        IdleSwim = 8
    }

    public enum TurnState
    {
        Idle = 0,
        TurnLeft = -1,
        TurnRight = 1
    }
    
    [Header("Estado Actual")]
    public MovementState currentState = MovementState.Idle;
    public TurnState currentTurnState = TurnState.Idle;
    public bool isRunning = false;
    public bool isCrouching = false;
    public bool isOnSlope = false;
    public float currentSlopeAngle = 0f;
    public bool isAttacking = false;
    public int enemiesInRange = 0;
    public bool isInWater = false;
    public bool isSwimming = false;
    public bool isDead = false;

    // Character Controller
    private CharacterController controller;
    
    // Variables de movimiento
    private Vector3 inputVector;
    private Vector3 moveDirection;
    private Vector3 velocity;
    private float currentSpeed = 0f;
    private float targetSpeed = 0f;
    
    // â­ VARIABLES DE RADIO DE GIRO NATURAL
    private Vector3 currentMoveDirection;
    private Vector3 targetMoveDirection;
    private Vector3 smoothedMoveDirection;
    private float currentTurnRadius = 0f;
    
    // â­ FIX: Variables separadas para rotaciÃ³n
    private float currentYaw = 0f;  // RotaciÃ³n horizontal (controlada por joystick)
    private Quaternion terrainRotation = Quaternion.identity;  // RotaciÃ³n del terreno (pitch/roll)
    
    // Variables de salto
    private bool canJump = true;
    private float jumpCooldownTimer = 0f;
    private bool hasJumped = false;
    
    // Variables de ataque
    private float attackCooldownTimer = 0f;
    private float attackTimer = 0f;
    private bool attackBuffered = false;
    private float attackBufferTimer = 0f;
    private List<GameObject> enemiesHit = new List<GameObject>();
    
    // Variables de detecciÃ³n de pendiente
    private RaycastHit slopeHit;
    private Vector3 slopeNormal;
    
    // â­ Variables para alineaciÃ³n con terreno
    private Vector3 smoothNormal = Vector3.up;
    
    // Variables de animaciÃ³n Turn/Look basado en cÃ¡mara
    private float currentTurn = 0f;
    private float targetTurn = 0f;
    private float currentLook = 0f;
    private float targetLook = 0f;
    private float lastCameraAngle = 0f;
    private float lastCameraVerticalAngle = 0f;

    // ğŸ­ Variables de Idle Variations
    private float idleTimer = 0f;
    private float nextIdleVariationTime = 0f;
    private int currentIdleVariation = 0;
    private bool isPlayingIdleVariation = false;
    private float idleVariationTimer = 0f;

    // ğŸŒŠ Variables de nataciÃ³n
    private Collider waterCollider = null;
    private float waterSurfaceY = 0f;
    private bool wasInWater = false;


    void Start()
    {
        controller = GetComponent<CharacterController>();
        if (controller == null)
        {
            controller = gameObject.AddComponent<CharacterController>();
            controller.height = 2f;
            controller.center = new Vector3(0, 1f, 0);
            controller.radius = 0.5f;
        }
        
        if (animator == null)
            animator = GetComponent<Animator>();
        
        if (audioSource == null)
            audioSource = GetComponent<AudioSource>();
        
        if (cameraTransform == null)
        {
            Camera mainCam = Camera.main;
            if (mainCam != null)
                cameraTransform = mainCam.transform;
        }
        
        if (attackPoint == null)
            attackPoint = transform;
        
        // Inicializar rotaciÃ³n
        currentYaw = transform.eulerAngles.y;

        // ğŸ“ Auto-configurar tamaÃ±o si estÃ¡ activado
        if (autoConfigureOnStart && dinosaurSize != DinosaurSize.Custom)
        {
            ApplySizePreset();
        }

		// âš¡ Cachear referencia al sistema de sueÃ±o
		sleepSystemCache = GetComponent<DinosaurSleepSystem>();

        // ğŸ­ Inicializar sistema de idle variations
        ResetIdleVariationTimer();

        SetupButtonListeners();
    }
    
    void SetupButtonListeners()
    {
        if (runButton != null)
        {
            runButton.onClick.RemoveAllListeners();
            runButton.onClick.AddListener(() => {
                isRunning = !isRunning;
                // Si activa correr mientras estÃ¡ agachado, se mantiene agachado
                // hasta que mueva el joystick (lÃ³gica en CalculateMovement)
            });
        }

        if (crouchButton != null)
        {
            crouchButton.onClick.RemoveAllListeners();
            crouchButton.onClick.AddListener(() => {
                isCrouching = !isCrouching;
                // Ya no desactivamos isRunning aquÃ­
                // El usuario puede tener run activo y crouch al mismo tiempo
            });
        }

        if (callButton != null)
        {
            callButton.onClick.RemoveAllListeners();
            // Si hay CallSystem configurado, no hacer nada aquÃ­ (CallSystem maneja el botÃ³n)
            // Si no hay CallSystem, usar la funciÃ³n antigua
            if (callSystem == null)
            {
                callButton.onClick.AddListener(PlayCallSound);
            }
        }

        if (jumpButton != null)
        {
            jumpButton.onClick.RemoveAllListeners();
            jumpButton.onClick.AddListener(TryJump);
        }

        if (attackButton != null)
        {
            attackButton.onClick.RemoveAllListeners();
            attackButton.onClick.AddListener(TryAttack);
        }

		if (eatButton != null)
		{
			eatButton.onClick.RemoveAllListeners();
			eatButton.onClick.AddListener(ToggleEating);
			eatButton.gameObject.SetActive(false); // Ocultar inicialmente
		}

		if (drinkButton != null)
		{
			drinkButton.onClick.RemoveAllListeners();
			drinkButton.onClick.AddListener(ToggleDrinking);
			drinkButton.gameObject.SetActive(false); // Ocultar inicialmente
		}
    }

    // ğŸ“ SISTEMA DE CONFIGURACIÃ“N AUTOMÃTICA POR TAMAÃ‘O
    [ContextMenu("Apply Size Preset")]
    public void ApplySizePreset()
    {
        if (dinosaurSize == DinosaurSize.Custom)
        {
            Debug.LogWarning("âš ï¸ TamaÃ±o configurado como 'Custom'. No se aplicarÃ¡n presets automÃ¡ticos.");
            return;
        }

        Debug.Log($"ğŸ“ Aplicando preset de tamaÃ±o: {dinosaurSize} (Altura: {modelHeight}m)");

        switch (dinosaurSize)
        {
            case DinosaurSize.Small:
                ApplySmallPreset();
                break;
            case DinosaurSize.Medium:
                ApplyMediumPreset();
                break;
            case DinosaurSize.Large:
                ApplyLargePreset();
                break;
        }

        // Actualizar Character Controller
        if (controller != null)
        {
            controller.height = modelHeight;
            controller.radius = modelHeight * 0.2f;
            controller.center = new Vector3(0, modelHeight * 0.5f, 0);
        }

        Debug.Log($"âœ… ConfiguraciÃ³n aplicada: Walk={walkSpeed}, Run={runSpeed}, Swim={swimSpeed}, WaterOffset={waterSurfaceOffset}");
    }

    void ApplySmallPreset()
    {
        // Velocidades
        walkSpeed = modelHeight * 1.2f;
        runSpeed = modelHeight * 2.5f;
        crouchSpeed = modelHeight * 0.6f;
        swimSpeed = modelHeight * 1.2f;
        turnSpeed = 180f;

        // Salto
        jumpHeight = modelHeight * 0.8f;
        jumpCooldown = 0.5f;

        // Gravedad
        gravity = -25f;
        terminalVelocity = -40f;

        // Agua
        waterSurfaceOffset = modelHeight * 0.5f;
        buoyancyForce = 15f;
        waterDrag = 0.75f;
        waterHysteresis = 0.6f;

        // Ataque
        attackRange = modelHeight * 0.6f;
        attackDamage = modelHeight * 10f;

        // Giro
        walkTurnRadius = 1.0f;
        runTurnRadius = 2.0f;
        crouchTurnRadius = 0.8f;
        maxRotationSpeed = 200f;
    }

    void ApplyMediumPreset()
    {
        // Velocidades
        walkSpeed = modelHeight * 1.0f;
        runSpeed = modelHeight * 2.2f;
        crouchSpeed = modelHeight * 0.5f;
        swimSpeed = modelHeight * 1.2f;
        turnSpeed = 120f;

        // Salto
        jumpHeight = modelHeight * 0.6f;
        jumpCooldown = 1.0f;

        // Gravedad
        gravity = -20f;
        terminalVelocity = -50f;

        // Agua
        waterSurfaceOffset = modelHeight * 0.45f;
        buoyancyForce = 9.8f;
        waterDrag = 0.80f;
        waterHysteresis = 0.6f;

        // Ataque
        attackRange = modelHeight * 0.5f;
        attackDamage = modelHeight * 10f;

        // Giro
        walkTurnRadius = 1.5f;
        runTurnRadius = 3.0f;
        crouchTurnRadius = 1.2f;
        maxRotationSpeed = 180f;
    }

    void ApplyLargePreset()
    {
        // Velocidades
        walkSpeed = modelHeight * 0.7f;
        runSpeed = modelHeight * 1.6f;
        crouchSpeed = modelHeight * 0.35f;
        swimSpeed = modelHeight * 0.9f;
        turnSpeed = 90f;

        // Salto
        jumpHeight = modelHeight * 0.4f;
        jumpCooldown = 2.0f;

        // Gravedad
        gravity = -15f;
        terminalVelocity = -60f;

        // Agua
        waterSurfaceOffset = modelHeight * 0.4f;
        buoyancyForce = 8f;
        waterDrag = 0.85f;
        waterHysteresis = 0.6f;

        // Ataque
        attackRange = modelHeight * 0.5f;
        attackDamage = modelHeight * 15f;

        // Giro
        walkTurnRadius = 2.5f;
        runTurnRadius = 5.0f;
        crouchTurnRadius = 2.0f;
        maxRotationSpeed = 120f;
    }

    void Update()
    {
		// ğŸ’€ Si estÃ¡ muerto, no hacer nada
		if (isDead)
		{
			// Detener todo movimiento
			moveDirection = Vector3.zero;
			velocity.x = 0f;
			velocity.z = 0f;
			currentSpeed = 0f;
			targetSpeed = 0f;
			isRunning = false;
			return;
		}

		// ğŸ“ Verificar si el CallSystem estÃ¡ activo y llamando
		if (callSystem != null && callSystem.IsCalling())
		{
			isCalling = true;
		}

        // Leer input del joystick
        GetInput();

		// ğŸ– Actualizar hambre, sed y estamina
		UpdateHungerThirstStamina();

		// ğŸ— Detectar comida y agua cercana
		DetectFoodAndWater();

        // Detectar pendientes
        CheckSlope();

        // Calcular movimiento y rotaciÃ³n
        CalculateMovement();

        // â­ FIX: Aplicar rotaciÃ³n separada
        ApplySeparatedRotation();

        // Aplicar movimiento
        ApplyMovement();

        // â­ Alinear con el terreno (solo afecta pitch/roll, no yaw)
        // ğŸŒŠ NO alinear cuando estÃ¡ nadando
        if (alignToTerrain && controller.isGrounded && !isSwimming)
        {
            AlignToTerrainFixed();
        }

        // ğŸŒŠ Resetear rotaciÃ³n a horizontal cuando estÃ¡ nadando
        if (isSwimming)
        {
            ResetRotationToHorizontal();
        }

        // Actualizar animaciones
        UpdateAnimations();

        // Actualizar sistema de ataque
        UpdateAttackSystem();

        // Actualizar Turn y Look basado en cÃ¡mara
        UpdateCameraBasedTurnAndLook();

        // ğŸ­ Actualizar sistema de Idle Variations
        UpdateIdleVariations();

        // Actualizar timers
        UpdateTimers();

        // Actualizar estado
        UpdateState();

        // Actualizar UI
        UpdateUI();

		// ğŸ“Š Actualizar barras de estadÃ­sticas
		UpdateStatsUI();
    }
    
    void GetInput()
    {
        if (movementJoystick != null)
        {
            inputVector = new Vector3(movementJoystick.Horizontal, 0, movementJoystick.Vertical);
        }
        else
        {
            inputVector = new Vector3(Input.GetAxis("Horizontal"), 0, Input.GetAxis("Vertical"));
        }

        // Limitar magnitud
        if (inputVector.magnitude > 1f)
            inputVector = inputVector.normalized;
    }
    
    void CheckSlope()
    {
        if (controller.isGrounded)
        {
            Vector3 origin = transform.position + Vector3.up * 0.5f;
            if (Physics.Raycast(origin, Vector3.down, out slopeHit, controller.height))
            {
                slopeNormal = slopeHit.normal;
                currentSlopeAngle = Vector3.Angle(Vector3.up, slopeNormal);
                isOnSlope = currentSlopeAngle > 1f && currentSlopeAngle < controller.slopeLimit;
            }
            else
            {
                isOnSlope = false;
                currentSlopeAngle = 0f;
                slopeNormal = Vector3.up;
            }
        }
        else
        {
            isOnSlope = false;
            currentSlopeAngle = 0f;
            slopeNormal = Vector3.up;
        }
    }
    
    void CalculateMovement()
    {
		// ğŸ– No moverse mientras come o bebe
		if (isEating || isDrinking)
		{
			targetSpeed = 0f;
			moveDirection = Vector3.zero;
			currentSpeed = 0f;
			return;
		}

        // â­ FIX: Calcular direcciÃ³n relativa a la cÃ¡mara de forma mÃ¡s estable
        if (inputVector.magnitude > turnInPlaceThreshold)
        {
            // ğŸƒ Si estÃ¡ agachado y tiene run activo, al mover el joystick sale del crouch
            if (isCrouching && isRunning && inputVector.magnitude > movementThreshold)
            {
                isCrouching = false;
                Debug.Log("ğŸƒ Saliendo de crouch porque se activÃ³ correr con movimiento");
            }

            // Obtener vectores de la cÃ¡mara
            Vector3 cameraForward = cameraTransform.forward;
            Vector3 cameraRight = cameraTransform.right;

            // Proyectar en plano horizontal
            cameraForward.y = 0;
            cameraRight.y = 0;
            cameraForward.Normalize();
            cameraRight.Normalize();

            // Calcular direcciÃ³n deseada basada en el input del joystick
            targetMoveDirection = (cameraForward * inputVector.z + cameraRight * inputVector.x).normalized;

            // Si estamos atacando y no podemos movernos, mantener direcciÃ³n actual
            if (isAttacking && !canMoveWhileAttacking)
            {
                targetMoveDirection = transform.forward;
            }

            // Suavizar la direcciÃ³n de movimiento
            if (currentMoveDirection == Vector3.zero)
            {
                currentMoveDirection = targetMoveDirection;
            }
            else
            {
                currentMoveDirection = Vector3.Slerp(currentMoveDirection, targetMoveDirection,
                    Time.deltaTime * turnSmoothness);
            }
            
            // ğŸŒŠ Calcular velocidad objetivo (diferente en agua)
            if (isInWater && isSwimming)
            {
                targetSpeed = swimSpeed;  // Velocidad de nataciÃ³n
            }
            else
            {
                // Determinar velocidad segÃºn el estado: crouch, run o walk
                if (isCrouching)
                {
                    targetSpeed = crouchSpeed;
                }
                else
                {
                    targetSpeed = isRunning ? runSpeed : walkSpeed;
                }
            }

            // Reducir velocidad durante el giro (no aplica en agua)
            if (!isInWater)
            {
                float angleToTarget = Vector3.Angle(transform.forward, currentMoveDirection);
                if (angleToTarget > lookAtTolerance)
                {
                    targetSpeed *= turningSpeedFactor;
                }
            }

            // Aplicar modificador de pendiente (no aplica en agua)
            if (isOnSlope && !isInWater)
            {
                float slopeFactor = Vector3.Dot(currentMoveDirection, slopeNormal);
                if (slopeFactor < 0) // Subiendo
                {
                    targetSpeed *= slopeSpeedMultiplier;
                }
            }
        }
        else
        {
            // Sin input
            targetSpeed = 0f;
            if (currentMoveDirection.magnitude > 0.1f)
            {
                currentMoveDirection = Vector3.Lerp(currentMoveDirection, Vector3.zero, Time.deltaTime * 5f);
            }
        }
        
        // Suavizar velocidad
        currentSpeed = Mathf.Lerp(currentSpeed, targetSpeed, Time.deltaTime * movementSmoothness);
        
        // Calcular direcciÃ³n de movimiento final
        moveDirection = transform.forward * currentSpeed;

        
        // Si no podemos movernos mientras atacamos
        if (isAttacking && !canMoveWhileAttacking)
        {
            moveDirection = Vector3.zero;
        }
    }
    
void ApplySeparatedRotation()
{
    if (inputVector.magnitude > turnInPlaceThreshold)
    {
        if (!isAttacking || canRotateWhileAttacking)
        {
            if (targetMoveDirection != Vector3.zero)
            {
                // Calcular Ã¡ngulo objetivo (direcciÃ³n deseada)
                float targetYaw = Mathf.Atan2(targetMoveDirection.x, targetMoveDirection.z) * Mathf.Rad2Deg;
                float angleDifference = Mathf.DeltaAngle(currentYaw, targetYaw);

                // Radio dinÃ¡mico de giro (segÃºn velocidad y estado)
                if (isCrouching)
                {
                    currentTurnRadius = crouchTurnRadius;
                }
                else
                {
                    currentTurnRadius = isRunning ? runTurnRadius : walkTurnRadius;
                }

                // Calcular velocidad de rotaciÃ³n
                float rotationStep = Mathf.Clamp(angleDifference, -maxRotationSpeed * Time.deltaTime, maxRotationSpeed * Time.deltaTime);
                currentYaw += rotationStep;

                // Aplicar rotaciÃ³n suave al transform
                Vector3 eulerRotation = transform.eulerAngles;
                eulerRotation.y = currentYaw;
                transform.eulerAngles = eulerRotation;

                // â­ Actualizar direcciÃ³n de movimiento para que siga la curva
                Quaternion turnRotation = Quaternion.Euler(0f, rotationStep * (1f / currentTurnRadius), 0f);
                currentMoveDirection = turnRotation * currentMoveDirection;

                // Moverse siguiendo el giro
                moveDirection = transform.forward * currentSpeed;
            }
        }
    }
    else
    {
        // Sin input, mantener orientaciÃ³n actual
        Vector3 eulerRotation = transform.eulerAngles;
        eulerRotation.y = currentYaw;
        transform.eulerAngles = eulerRotation;
    }
}


    
void ApplyMovement()
{
    // âœ… ACTUALIZAR TIEMPO EN SUELO PRIMERO
    bool wasGrounded = controller.isGrounded;

    // ğŸŒŠ SISTEMA DE NATACIÃ“N
    if (isInWater)
    {
        // âœ… Calcular profundidad real del agua (desde el centro del personaje)
        float waterDepth = waterSurfaceY - transform.position.y;
        bool isDeepEnoughToSwim = waterDepth >= waterSurfaceOffset;

        if (isDeepEnoughToSwim)
        {
            // ğŸŠ AGUA PROFUNDA - ACTIVAR NATACIÃ“N

            // âœ… FLOTACIÃ“N - aplicar fuerza hacia arriba
            velocity.y += buoyancyForce * Time.deltaTime;

            // Limitar velocidad vertical en agua
            velocity.y = Mathf.Clamp(velocity.y, -2f, 2f);

            // Aplicar resistencia del agua (drag)
            velocity *= waterDrag;

            // Determinar si estÃ¡ nadando (moviÃ©ndose)
            isSwimming = inputVector.magnitude > 0.1f;

            // No resetear hasJumped en agua (a menos que se permita saltar desde agua)
            if (canJumpFromWater)
            {
                canJump = true;
                hasJumped = false;
            }
        }
        else
        {
            // ğŸš¶ AGUA POCO PROFUNDA - CAMINAR NORMALMENTE

            isSwimming = false;

            // Aplicar fÃ­sica normal como en tierra
            if (controller.isGrounded && velocity.y < 0f)
            {
                velocity.y = -2f;
            }

            // Aplicar gravedad normal
            velocity.y += gravity * Time.deltaTime;
            velocity.y = Mathf.Max(velocity.y, terminalVelocity);

            // Aplicar fuerza adicional si estÃ¡ en pendiente
            if (isOnSlope && controller.isGrounded)
            {
                velocity += Vector3.down * slopeForceDown * Time.deltaTime;
            }
        }
    }
    else
    {
        // ğŸƒ MOVIMIENTO NORMAL (FUERA DEL AGUA)

        // Mantener pegado al suelo (evita saltos falsos cuando ya estÃ¡ en tierra)
        if (controller.isGrounded && velocity.y < 0f)
        {
            velocity.y = -2f;
        }

        // Aplicar gravedad
        velocity.y += gravity * Time.deltaTime;
        velocity.y = Mathf.Max(velocity.y, terminalVelocity);

        // Aplicar fuerza adicional si estÃ¡ en pendiente
        if (isOnSlope && controller.isGrounded)
        {
            velocity += Vector3.down * slopeForceDown * Time.deltaTime;
        }

        isSwimming = false;
    }

    // Combinar movimiento horizontal y vertical
    Vector3 finalMove = moveDirection + velocity;

    // Aplicar movimiento
    controller.Move(finalMove * Time.deltaTime);

    // âœ… ACTUALIZAR ESTADO DE SUELO DESPUÃ‰S DEL MOVIMIENTO
    if (controller.isGrounded && !isSwimming)
    {
        lastGroundedTime = Time.time;

        // ğŸ”¹ Resetear hasJumped cuando aterriza
        if (hasJumped)
        {
            hasJumped = false;
        }
    }
}


    
    void AlignToTerrainFixed()
    {
        // â­ FIX: Nueva implementaciÃ³n que no afecta la rotaciÃ³n Y
        
        // Detectar el terreno debajo
        Vector3 rayOrigin = transform.position + Vector3.up * 0.1f;
        RaycastHit hit;
        
        Vector3 targetNormal = Vector3.up;
        
        if (Physics.Raycast(rayOrigin, Vector3.down, out hit, 5f))
        {
            targetNormal = hit.normal;
            
            // Limitar el Ã¡ngulo mÃ¡ximo de inclinaciÃ³n
            float angleFromUp = Vector3.Angle(Vector3.up, targetNormal);
            if (angleFromUp > maxTerrainTilt)
            {
                targetNormal = Vector3.Lerp(targetNormal, Vector3.up, 
                    (angleFromUp - maxTerrainTilt) / angleFromUp);
            }
        }
        
        // Suavizar la normal
        smoothNormal = Vector3.Slerp(smoothNormal, targetNormal, Time.deltaTime * terrainAlignmentSpeed);
        
        // â­ FIX: Calcular rotaciÃ³n del terreno sin afectar Y
        // Crear una rotaciÃ³n que alinee con el terreno pero mantenga el yaw actual
        Vector3 forward = Quaternion.Euler(0, currentYaw, 0) * Vector3.forward;
        Vector3 projectedForward = Vector3.ProjectOnPlane(forward, smoothNormal).normalized;
        
        if (projectedForward.magnitude > 0.1f)
        {
            // Crear quaternion que mira hacia adelante con la normal del terreno
            Quaternion targetTerrainRotation = Quaternion.LookRotation(projectedForward, smoothNormal);
            
            // â­ FIX: Extraer solo pitch y roll, manteniendo el yaw actual
            Vector3 terrainEuler = targetTerrainRotation.eulerAngles;
            terrainEuler.y = currentYaw; // Forzar el yaw a mantenerse
            
            // Aplicar la rotaciÃ³n final
            Quaternion finalRotation = Quaternion.Euler(terrainEuler);
            transform.rotation = Quaternion.Slerp(transform.rotation, finalRotation, 
                Time.deltaTime * terrainAlignmentSpeed);
        }
    }

    // ğŸŒŠ Resetear rotaciÃ³n a horizontal al nadar
    void ResetRotationToHorizontal()
    {
        // Crear rotaciÃ³n horizontal (pitch=0, roll=0, mantener yaw)
        Vector3 targetEuler = transform.eulerAngles;
        targetEuler.x = 0f;  // Sin pitch (inclinaciÃ³n adelante/atrÃ¡s)
        targetEuler.z = 0f;  // Sin roll (inclinaciÃ³n lateral)

        // Suavizar la transiciÃ³n a horizontal
        Quaternion targetRotation = Quaternion.Euler(targetEuler);
        transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation,
            Time.deltaTime * terrainAlignmentSpeed);

        // TambiÃ©n resetear smoothNormal para que cuando salga del agua no tenga valores residuales
        smoothNormal = Vector3.Lerp(smoothNormal, Vector3.up, Time.deltaTime * terrainAlignmentSpeed);
    }

void UpdateAnimations()
{
    if (animator == null) return;

    // ğŸŒŠ PARÃMETROS DE NATACIÃ“N
    animator.SetBool("IsInWater", isInWater);
    animator.SetBool("IsSwimming", isSwimming);

    // ğŸ”¹ 1. Velocidad normalizada (0 = quieto, 1 = corriendo/nadando)
    float normalizedSpeed = isInWater ? (currentSpeed / swimSpeed) : (currentSpeed / runSpeed);
    animator.SetFloat("Speed", normalizedSpeed);

    // ğŸ”¹ 2. Estados principales
    animator.SetBool("IsGrounded", controller.isGrounded && !isInWater);
    animator.SetBool("IsRunning", isRunning && !isInWater);
    animator.SetBool("IsCrouching", isCrouching && !isInWater);
    animator.SetBool("IsAttacking", isAttacking);
    animator.SetFloat("VerticalSpeed", velocity.y);

    // ğŸ”¹ 3. ParÃ¡metros de direcciÃ³n (si los usas en tu blend tree)
    // âœ… Usar dampTime para suavizar las transiciones
    if (inputVector.magnitude > 0.1f)
    {
        Vector3 localMove = transform.InverseTransformDirection(currentMoveDirection);
        animator.SetFloat("MoveX", localMove.x, directionAnimationDampTime, Time.deltaTime);
        animator.SetFloat("MoveZ", localMove.z, directionAnimationDampTime, Time.deltaTime);
    }
    else
    {
        // Suavizar la transiciÃ³n a 0 tambiÃ©n
        animator.SetFloat("MoveX", 0f, directionAnimationDampTime, Time.deltaTime);
        animator.SetFloat("MoveZ", 0f, directionAnimationDampTime, Time.deltaTime);
    }

    // ğŸ”¹ 4. ParÃ¡metros de cÃ¡mara / mirada
    animator.SetFloat("Turn", currentTurn);
    animator.SetFloat("Look", currentLook);

    // ğŸ­ 5. ParÃ¡metro de Idle Variation
    animator.SetInteger("IdleVariation", currentIdleVariation);

}

    
    void UpdateCameraBasedTurnAndLook()
    {
        if (!enableStaticTurn || cameraTransform == null) 
        {
            currentTurn = Mathf.Lerp(currentTurn, 0f, Time.deltaTime * turnTransitionSpeed);
            currentLook = Mathf.Lerp(currentLook, 0f, Time.deltaTime * lookTransitionSpeed);
            return;
        }
        
        // Sistema de Turn basado en la diferencia entre cÃ¡mara y dinosaurio
        Vector3 cameraForward = cameraTransform.forward;
        cameraForward.y = 0;
        cameraForward.Normalize();
        
        Vector3 dinoForward = transform.forward;
        dinoForward.y = 0;
        dinoForward.Normalize();
        
        float angleToCamera = Vector3.SignedAngle(dinoForward, cameraForward, Vector3.up);
        
        // Determinar el estado de Turn basado en el Ã¡ngulo
        if (Mathf.Abs(angleToCamera) > turnDetectionThreshold)
        {
            if (angleToCamera > 0)
            {
                targetTurn = Mathf.Min(angleToCamera / 90f, maxTurnLookValue); // Girar a la derecha
                currentTurnState = TurnState.TurnRight;
            }
            else
            {
                targetTurn = Mathf.Max(angleToCamera / 90f, -maxTurnLookValue); // Girar a la izquierda
                currentTurnState = TurnState.TurnLeft;
            }
        }
        else
        {
            targetTurn = 0f;
            currentTurnState = TurnState.Idle;
        }
        
        // Sistema de Look (vertical)
        if (enableVerticalLook)
        {
            float cameraPitch = cameraTransform.eulerAngles.x;
            if (cameraPitch > 180f) cameraPitch -= 360f;
            
            if (Mathf.Abs(cameraPitch) > lookDetectionThreshold)
            {
                if (cameraPitch < 0) // Mirando hacia arriba
                {
                    targetLook = Mathf.Min(-cameraPitch / 45f, maxTurnLookValue);
                }
                else // Mirando hacia abajo
                {
                    targetLook = Mathf.Max(-cameraPitch / 45f, -maxTurnLookValue);
                }
            }
            else
            {
                targetLook = 0f;
            }
        }
        else
        {
            targetLook = 0f;
        }
        
        // Suavizar las transiciones
        currentTurn = Mathf.Lerp(currentTurn, targetTurn, Time.deltaTime * turnTransitionSpeed);
        currentLook = Mathf.Lerp(currentLook, targetLook, Time.deltaTime * lookTransitionSpeed);
        
        // Limitar valores mÃ¡ximos
        currentTurn = Mathf.Clamp(currentTurn, -maxTurnLookValue, maxTurnLookValue);
        currentLook = Mathf.Clamp(currentLook, -maxTurnLookValue, maxTurnLookValue);
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ­ SISTEMA DE IDLE VARIATIONS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /// <summary>
    /// Actualiza el sistema de idle variations (rascarse, mirar alrededor, etc.)
    /// </summary>
    void UpdateIdleVariations()
    {
        if (!enableIdleVariations || animator == null || numberOfIdleVariations <= 0)
        {
            // Si estÃ¡ desactivado, asegurar que estÃ© en idle normal (0)
            if (currentIdleVariation != 0)
            {
                currentIdleVariation = 0;
                isPlayingIdleVariation = false;
            }
            return;
        }

        // Verificar si estÃ¡ en estado Idle (completamente quieto)
        bool isInIdleState = currentState == MovementState.Idle &&
                            !isAttacking &&
                            !isCalling &&
                            !isEating &&
                            !isDrinking &&
                            controller.isGrounded &&
                            !isInWater;

        // Si requiere estar completamente quieto
        if (onlyWhenFullyIdle)
        {
            isInIdleState = isInIdleState &&
                           currentSpeed <= 0.01f &&
                           inputVector.magnitude <= 0.01f;
        }

        // Si NO estÃ¡ en idle, resetear sistema
        if (!isInIdleState)
        {
            if (isPlayingIdleVariation || currentIdleVariation != 0)
            {
                currentIdleVariation = 0;
                isPlayingIdleVariation = false;
            }
            idleTimer = 0f;
            return;
        }

        // âœ… EstÃ¡ en Idle - Actualizar lÃ³gica

        if (isPlayingIdleVariation)
        {
            // ğŸ¬ EstÃ¡ reproduciendo una idle variation
            idleVariationTimer += Time.deltaTime;

            // Cuando termina la duraciÃ³n, volver al idle normal
            if (idleVariationTimer >= idleVariationDuration)
            {
                currentIdleVariation = 0;
                isPlayingIdleVariation = false;
                ResetIdleVariationTimer();
            }
        }
        else
        {
            // â±ï¸ EstÃ¡ en idle normal - contar tiempo
            idleTimer += Time.deltaTime;

            // Cuando llega al tiempo objetivo, decidir si activar variation
            if (idleTimer >= nextIdleVariationTime)
            {
                // Tirar dado para ver si activa variation
                float randomChance = Random.Range(0f, 100f);

                if (randomChance <= idleVariationChance)
                {
                    // âœ… Activar idle variation aleatoria (1 a numberOfIdleVariations)
                    currentIdleVariation = Random.Range(1, numberOfIdleVariations + 1);
                    isPlayingIdleVariation = true;
                    idleVariationTimer = 0f;

                    Debug.Log($"ğŸ­ Activando Idle Variation {currentIdleVariation}");
                }
                else
                {
                    // âŒ No activar, resetear timer para intentar de nuevo
                    ResetIdleVariationTimer();
                }
            }
        }
    }

    /// <summary>
    /// Resetea el timer de idle variations con un tiempo aleatorio
    /// </summary>
    void ResetIdleVariationTimer()
    {
        idleTimer = 0f;
        nextIdleVariationTime = Random.Range(minIdleTimeBeforeVariation, maxIdleTimeBeforeVariation);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // âš”ï¸ SISTEMA DE ATAQUE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    void UpdateAttackSystem()
    {
        // Detectar enemigos en rango
        DetectEnemiesInRange();
        
        // Procesar buffer de ataque
        if (enableAttackBuffer && attackBuffered)
        {
            attackBufferTimer -= Time.deltaTime;
            if (attackBufferTimer <= 0f)
            {
                attackBuffered = false;
            }
            
            // Intentar ejecutar el ataque buffereado
            if (attackCooldownTimer <= 0f && !isAttacking)
            {
                ExecuteAttack();
                attackBuffered = false;
            }
        }
        
        // Timer del ataque actual
        if (isAttacking)
        {
            attackTimer -= Time.deltaTime;
            if (attackTimer <= 0f)
            {
                EndAttack();
            }
        }
		
		if (isCalling)
	{
		callTimer -= Time.deltaTime;

		// Evitar ataque mientras ruge
		isAttacking = false;

		// Cuando termina el rugido
		if (callTimer <= 0f)
		{
			isCalling = false;
		}
	}
        
        // Cooldown
        if (attackCooldownTimer > 0f)
        {
            attackCooldownTimer -= Time.deltaTime;
        }
    }
    
    void DetectEnemiesInRange()
    {
        Vector3 attackPosition = attackPoint != null ? attackPoint.position : transform.position + transform.forward * 1f;
        Collider[] nearbyEnemies = Physics.OverlapSphere(attackPosition, attackRange * 1.5f, enemyLayer);
        
        enemiesInRange = 0;
        foreach (Collider enemy in nearbyEnemies)
        {
            Vector3 directionToEnemy = (enemy.transform.position - transform.position).normalized;
            float angleToEnemy = Vector3.Angle(transform.forward, directionToEnemy);
            
            if (angleToEnemy <= attackAngle / 2f)
            {
                float distanceToEnemy = Vector3.Distance(transform.position, enemy.transform.position);
                if (distanceToEnemy <= attackRange)
                {
                    enemiesInRange++;
                }
            }
        }
    }
    
    public void TryAttack()
    {
		if (isCalling) return;

		// ğŸ– No atacar mientras come o bebe
		if (isEating || isDrinking) return;

        // âœ… Usar variable unificada lastGroundedTime
        bool canAttackNow = (controller.isGrounded || Time.time - lastGroundedTime < groundedTolerance || canAttackInAir)
                           && attackCooldownTimer <= 0f
                           && !isAttacking;

        if (canAttackNow)
        {
            ExecuteAttack();
        }
        else if (enableAttackBuffer)
        {
            attackBuffered = true;
            attackBufferTimer = attackBufferTime;
        }
    }
    
    void ExecuteAttack()
    {
        isAttacking = true;
        attackTimer = attackDuration;
        attackCooldownTimer = attackCooldown;
        currentState = MovementState.Attacking;
        
        // Limpiar lista de enemigos golpeados
        enemiesHit.Clear();
        
        // AnimaciÃ³n
        if (animator != null)
        {
            animator.SetTrigger("Attack");
        }
        
        // Sonido
        PlayAttackSound();
        
        // Hacer daÃ±o inmediatamente
        PerformAttackDamage();
    }
    
    void PerformAttackDamage()
    {
        Vector3 attackPosition = attackPoint != null ? attackPoint.position : transform.position + transform.forward * 1f;
        
        // Detectar enemigos en el Ã¡rea de ataque
        Collider[] hitColliders = Physics.OverlapSphere(attackPosition, attackRange, enemyLayer);
        
        foreach (Collider hit in hitColliders)
        {
            if (enemiesHit.Contains(hit.gameObject))
                continue;
                
            Vector3 directionToTarget = (hit.transform.position - transform.position).normalized;
            float angleToTarget = Vector3.Angle(transform.forward, directionToTarget);
            
            if (angleToTarget <= attackAngle / 2f)
            {
                enemiesHit.Add(hit.gameObject);
                
                // Aplicar daÃ±o
                IDamageable damageable = hit.GetComponent<IDamageable>();
                if (damageable != null)
                {
                    damageable.TakeDamage(attackDamage);
                }
                
                // Aplicar knockback
                if (attackKnockback > 0f)
                {
                    Rigidbody rb = hit.GetComponent<Rigidbody>();
                    if (rb != null)
                    {
                        Vector3 knockbackDirection = directionToTarget;
                        knockbackDirection.y = 0.3f;
                        rb.AddForce(knockbackDirection.normalized * attackKnockback, ForceMode.Impulse);
                    }
                }
                
                // Sonido de impacto
                PlayHitSound();
            }
        }
    }
    
    void EndAttack()
    {
        isAttacking = false;
        enemiesHit.Clear();
        
        if (controller.isGrounded)
        {
            currentState = inputVector.magnitude > movementThreshold ? 
                (isRunning ? MovementState.Run : MovementState.Walk) : MovementState.Idle;
        }
    }
    
	public void TryJump()
	{
		// ğŸ– No saltar mientras come o bebe
		if (isEating || isDrinking) return;

		// âœ… FIX: Usar lastGroundedTime con tolerancia para evitar timing issues
		// El botÃ³n ya estÃ¡ deshabilitado correctamente en la UI
		bool isGroundedRecently = (Time.time - lastGroundedTime) <= 0.2f;

		if (!isGroundedRecently && !controller.isGrounded)
		{
			return;
		}
		if (!canJump) return;
		if (isAttacking) return;

		// Ejecutar salto
		DoJump();
	}
	
private void DoJump()
{
    velocity.y = Mathf.Sqrt(Mathf.Max(0.0001f, jumpHeight) * -2f * gravity);
    canJump = false;
    hasJumped = true;
    jumpCooldownTimer = jumpCooldown;

    if (animator != null)
    {
        animator.ResetTrigger("Jump");
        animator.SetTrigger("Jump");
        animator.SetBool("IsGrounded", false);
        animator.SetFloat("VerticalSpeed", velocity.y);
    }

    PlayJumpSound();
}

void UpdateTimers()
{
    // âœ… Control del cooldown de salto - SIMPLIFICADO
    if (jumpCooldownTimer > 0f)
    {
        jumpCooldownTimer -= Time.deltaTime;

        // Cuando el cooldown termina, permitir saltar de nuevo
        if (jumpCooldownTimer <= 0f)
        {
            jumpCooldownTimer = 0f;
            canJump = true;  // âœ… Resetear aquÃ­ cuando el cooldown termine
        }
    }

    // Control del cooldown del ataque
    if (attackCooldownTimer > 0f)
    {
        attackCooldownTimer -= Time.deltaTime;
    }

    // Control del buffer de ataque (si lo tienes activo)
    if (enableAttackBuffer && attackBuffered)
    {
        attackBufferTimer -= Time.deltaTime;
        if (attackBufferTimer <= 0f)
        {
            attackBuffered = false;
        }
    }
}

    
    void UpdateState()
    {
        // ğŸŒŠ Estados de nataciÃ³n tienen prioridad
        if (isInWater)
        {
            if (isSwimming && currentSpeed > movementThreshold)
            {
                currentState = MovementState.Swimming;
            }
            else
            {
                currentState = MovementState.IdleSwim;
            }
        }
        else if (isAttacking)
        {
            currentState = MovementState.Attacking;
        }
        else if (!controller.isGrounded)
        {
            currentState = velocity.y > 0 ? MovementState.Jump : MovementState.Falling;
        }
        else if (currentSpeed > movementThreshold)
        {
            // Determinar el estado segÃºn crouch, run o walk
            if (isCrouching)
            {
                currentState = MovementState.Crouch;
            }
            else
            {
                currentState = isRunning ? MovementState.Run : MovementState.Walk;
            }
        }
        else
        {
            currentState = MovementState.Idle;
        }
    }
    
    void UpdateUI()
    {
        if (runButton != null)
        {
            ColorBlock colors = runButton.colors;
            colors.normalColor = isRunning ? Color.green : Color.white;
            runButton.colors = colors;
            // Ya no deshabilitamos el botÃ³n cuando estÃ¡ agachado
            // El usuario puede activar run mientras estÃ¡ agachado
        }

        if (crouchButton != null)
        {
            ColorBlock colors = crouchButton.colors;
            colors.normalColor = isCrouching ? Color.yellow : Color.white;
            crouchButton.colors = colors;
        }

        // âœ… DESHABILITAR BOTÃ“N DE SALTO cuando no se puede usar
        if (jumpButton != null)
        {
            bool canJumpNow = controller.isGrounded && canJump && !isAttacking;
            jumpButton.interactable = canJumpNow;

            // Cambiar color visual para feedback
            ColorBlock colors = jumpButton.colors;
            colors.normalColor = canJumpNow ? Color.white : Color.gray;
            jumpButton.colors = colors;
        }

        if (attackButton != null)
        {
            ColorBlock colors = attackButton.colors;
            if (isAttacking)
                colors.normalColor = Color.red;
            else if (attackCooldownTimer > 0)
                colors.normalColor = Color.gray;
            else if (enemiesInRange > 0)
                colors.normalColor = Color.yellow;
            else
                colors.normalColor = Color.white;
            attackButton.colors = colors;
        }
    }
    
    // MÃ©todos de audio
	void PlayCallSound()
	{
		// Si ya estÃ¡ rugiendo o atacando, no permitir otro rugido
		if (isCalling || isAttacking) return;

		// ğŸ– No rugir mientras come o bebe
		if (isEating || isDrinking) return;

		// Activar rugido
		isCalling = true;
		callTimer = callDuration;

		// Sonido de rugido
		if (audioSource != null && callSounds.Length > 0)
		{
			AudioClip clip = callSounds[Random.Range(0, callSounds.Length)];
			audioSource.PlayOneShot(clip);
		}

		// AnimaciÃ³n
		if (animator != null)
		{
			animator.ResetTrigger("Attack");
			animator.SetTrigger("Call");
			animator.SetBool("IsAttacking", false);
		}
	}

    
    void PlayJumpSound()
    {
        if (audioSource != null && jumpSounds.Length > 0)
        {
            AudioClip clip = jumpSounds[Random.Range(0, jumpSounds.Length)];
            audioSource.PlayOneShot(clip);
        }
    }
    
    void PlayAttackSound()
    {
        if (audioSource != null && attackSounds.Length > 0)
        {
            AudioClip clip = attackSounds[Random.Range(0, attackSounds.Length)];
            audioSource.PlayOneShot(clip);
        }
    }
    
    void PlayHitSound()
    {
        if (audioSource != null && hitSounds.Length > 0)
        {
            AudioClip clip = hitSounds[Random.Range(0, hitSounds.Length)];
            audioSource.PlayOneShot(clip);
        }
    }
    
    // MÃ©todos de pasos (llamados por eventos de animaciÃ³n)
    public void PlayFootstep()
    {
        if (audioSource != null)
        {
            AudioClip[] clips = isRunning ? runSounds : walkSounds;
            if (clips.Length > 0)
            {
                AudioClip clip = clips[Random.Range(0, clips.Length)];
                audioSource.PlayOneShot(clip, 0.7f);
            }
        }
    }

    // ğŸ”½ MÃ©todo para pasos en crouch (llamado por eventos de animaciÃ³n de crouch)
    public void PlayCrouchFootstep()
    {
        if (audioSource != null)
        {
            if (crouchWalkSounds.Length > 0)
            {
                AudioClip clip = crouchWalkSounds[Random.Range(0, crouchWalkSounds.Length)];
                audioSource.PlayOneShot(clip, 0.6f); // Volumen un poco mÃ¡s bajo que walk
            }
            else
            {
                // Fallback: si no hay sonidos de crouch, usar walk sounds
                if (walkSounds.Length > 0)
                {
                    AudioClip clip = walkSounds[Random.Range(0, walkSounds.Length)];
                    audioSource.PlayOneShot(clip, 0.5f);
                }
            }
        }
    }

    public void PlayLandSound()
    {
        if (audioSource != null && landSounds.Length > 0)
        {
            AudioClip clip = landSounds[Random.Range(0, landSounds.Length)];
            audioSource.PlayOneShot(clip);
        }
    }
    
    void OnDrawGizmosSelected()
    {
        if (!showAttackGizmos) return;
        
        Vector3 attackPosition = attackPoint != null ? attackPoint.position : transform.position + transform.forward * 1f;
        
        // Gizmos de ataque
        Gizmos.color = isAttacking ? Color.red : (enemiesInRange > 0 ? Color.yellow : Color.cyan);
        Gizmos.DrawWireSphere(attackPosition, attackRange);
        
        if (Application.isPlaying)
        {
            Gizmos.color = Color.red;
            Vector3 forward = transform.forward;
            Vector3 right = Quaternion.Euler(0, attackAngle / 2f, 0) * forward;
            Vector3 left = Quaternion.Euler(0, -attackAngle / 2f, 0) * forward;
            
            Gizmos.DrawLine(transform.position, transform.position + right * attackRange);
            Gizmos.DrawLine(transform.position, transform.position + left * attackRange);
        }
        
        // Gizmos de ground detection
        if (Application.isPlaying)
        {
            Vector3 rayStart = transform.position + Vector3.up * 0.5f;
            Gizmos.color = controller != null && controller.isGrounded ? Color.green : Color.red;
            Gizmos.DrawLine(rayStart, rayStart + Vector3.down * 2f);
            
            if (isOnSlope)
            {
                Gizmos.color = Color.yellow;
                Gizmos.DrawLine(slopeHit.point, slopeHit.point + slopeHit.normal * 2f);
            }
            
            // Gizmos de alineaciÃ³n con terreno
            if (alignToTerrain)
            {
                // Mostrar normal suavizada del terreno
                Gizmos.color = Color.magenta;
                Gizmos.DrawLine(transform.position, transform.position + smoothNormal * 3f);
                
                // Mostrar up vector del transform
                Gizmos.color = Color.cyan;
                Gizmos.DrawLine(transform.position, transform.position + transform.up * 2.5f);
            }
        }
        
        // Gizmos de direcciÃ³n de movimiento
        if (Application.isPlaying && currentMoveDirection != Vector3.zero)
        {
            // DirecciÃ³n actual
            Gizmos.color = Color.green;
            Gizmos.DrawLine(transform.position + Vector3.up * 0.5f, 
                           transform.position + Vector3.up * 0.5f + currentMoveDirection * 2f);
            
            // DirecciÃ³n objetivo
            if (targetMoveDirection != Vector3.zero)
            {
                Gizmos.color = Color.yellow;
                Gizmos.DrawLine(transform.position + Vector3.up * 0.7f, 
                               transform.position + Vector3.up * 0.7f + targetMoveDirection * 2f);
            }
        }

        // ğŸŒŠ Gizmos de agua
        if (Application.isPlaying && isInWater && waterCollider != null)
        {
            Gizmos.color = Color.cyan;
            Gizmos.DrawWireSphere(transform.position, 1f);

            // LÃ­nea de superficie del agua
            Gizmos.color = Color.blue;
            Vector3 surfacePos = new Vector3(transform.position.x, waterSurfaceY, transform.position.z);
            Gizmos.DrawLine(surfacePos + Vector3.left * 2f, surfacePos + Vector3.right * 2f);
            Gizmos.DrawLine(surfacePos + Vector3.forward * 2f, surfacePos + Vector3.back * 2f);
        }
    }

    // ğŸŒŠ SISTEMA DE DETECCIÃ“N DE AGUA
    void OnTriggerEnter(Collider other)
    {
        // Verificar si el collider estÃ¡ en el layer de agua
        if (((1 << other.gameObject.layer) & waterLayer) != 0)
        {
            // Guardar referencia al collider del agua
            waterCollider = other;
            UpdateWaterSurface(other);

            // âœ… NO activar isInWater inmediatamente, esperar a verificar profundidad
            Debug.Log("ğŸŒŠ Dinosaurio tocÃ³ el agua (verificando profundidad...)");
        }
    }

    void OnTriggerStay(Collider other)
    {
        // Verificar si el collider estÃ¡ en el layer de agua
        if (((1 << other.gameObject.layer) & waterLayer) != 0)
        {
            // Actualizar altura de superficie del agua
            UpdateWaterSurface(other);

            // âœ… Calcular profundidad del agua
            float waterDepth = waterSurfaceY - transform.position.y;

            // ğŸ”„ HISTÃ‰RESIS: Usar diferentes umbrales para entrar/salir
            // Esto evita el parpadeo cuando el dinosaurio flota
            float enterThreshold = waterSurfaceOffset;
            float exitThreshold = waterSurfaceOffset * waterHysteresis;

            // âœ… Solo activar isInWater si estÃ¡ lo suficientemente profundo
            if (!isInWater && waterDepth >= enterThreshold)
            {
                // EntrÃ³ a agua profunda
                isInWater = true;
                wasInWater = true;
                Debug.Log($"ğŸŠ Agua profunda detectada! (profundidad: {waterDepth:F2}m, umbral: {enterThreshold:F2}m)");
            }
            // âœ… Solo desactivar si la profundidad baja significativamente (histÃ©resis)
            else if (isInWater && waterDepth < exitThreshold)
            {
                // SaliÃ³ a agua poco profunda (con tolerancia)
                isInWater = false;
                isSwimming = false;
                Debug.Log($"ğŸš¶ Agua poco profunda (profundidad: {waterDepth:F2}m, umbral salida: {exitThreshold:F2}m)");
            }
        }
    }

    void OnTriggerExit(Collider other)
    {
        // Verificar si el collider estÃ¡ en el layer de agua
        if (((1 << other.gameObject.layer) & waterLayer) != 0)
        {
            ExitWater();
        }
    }

    void UpdateWaterSurface(Collider water)
    {
        // Calcular la superficie del agua (parte superior del collider)
        Bounds bounds = water.bounds;
        waterSurfaceY = bounds.max.y;
    }

    void ExitWater()
    {
        isInWater = false;
        isSwimming = false;
        waterCollider = null;

        Debug.Log("ğŸ–ï¸ Dinosaurio saliÃ³ del agua!");
    }

	// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	// ğŸ– SISTEMA DE HAMBRE, SED Y ESTAMINA
	// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	/// <summary>
	/// Actualiza hambre, sed y estamina
	/// </summary>
	void UpdateHungerThirstStamina()
	{
		// ğŸ– No actualizar si estÃ¡ comiendo o bebiendo (se maneja en sus mÃ©todos)
		if (!isEating && !isDrinking)
		{
			// Degradar hambre y sed constantemente
			currentHunger -= hungerDecayRate * Time.deltaTime;
			currentThirst -= thirstDecayRate * Time.deltaTime;

			// Limitar valores
			currentHunger = Mathf.Clamp(currentHunger, 0f, maxHunger);
			currentThirst = Mathf.Clamp(currentThirst, 0f, maxThirst);
		}

		// âš¡ Estamina - Consumo al correr (basado en velocidad real, no en el botÃ³n)
		if (isRunning && currentSpeed > movementThreshold && !isEating && !isDrinking)
		{
			currentStamina -= staminaDrainRate * Time.deltaTime;

			// Si se queda sin estamina, dejar de correr automÃ¡ticamente
			if (currentStamina <= 0f)
			{
				currentStamina = 0f;
				isRunning = false;
			}
		}
		// âš¡ Estamina - RegeneraciÃ³n (cuando NO estÃ¡ corriendo activamente)
		// âœ… NUEVO: Regenera al caminar Y cuando estÃ¡ quieto (solo NO regenera al correr)
		else if (!isEating && !isDrinking)
		{
			// Verificar si estÃ¡ durmiendo para regenerar mÃ¡s rÃ¡pido (usando referencia cacheada)
			// NOTA: Cuando estÃ¡ durmiendo, el DinosaurSleepSystem tambiÃ©n maneja la regeneraciÃ³n
			// porque este script se desactiva durante el sueÃ±o
			float regenRate = (sleepSystemCache != null && sleepSystemCache.IsSleeping) ? staminaSleepRegenRate : staminaRegenRate;

			currentStamina += regenRate * Time.deltaTime;
		}

		// Limitar estamina
		currentStamina = Mathf.Clamp(currentStamina, 0f, maxStamina);
	}

	/// <summary>
	/// Detecta comida y agua cercana
	/// </summary>
	void DetectFoodAndWater()
	{
		// ğŸ— Detectar comida cercana
		Collider[] foodColliders = Physics.OverlapSphere(transform.position, foodDetectionRange);
		nearbyFood = null;

		foreach (Collider col in foodColliders)
		{
			if (col.CompareTag("Food"))
			{
				nearbyFood = col.gameObject;
				break;
			}
		}

		// ğŸ’§ Detectar agua cercana
		Collider[] waterColliders = Physics.OverlapSphere(transform.position, foodDetectionRange);
		nearbyWater = null;

		foreach (Collider col in waterColliders)
		{
			if (col.CompareTag("Water"))
			{
				nearbyWater = col.gameObject;
				break;
			}
		}

		// ğŸ–¼ï¸ Mostrar/ocultar botones segÃºn proximidad
		if (eatButton != null)
		{
			eatButton.gameObject.SetActive(nearbyFood != null && !isDrinking);
		}

		if (drinkButton != null)
		{
			drinkButton.gameObject.SetActive(nearbyWater != null && !isEating);
		}
	}

	/// <summary>
	/// Alternar comer
	/// </summary>
	public void ToggleEating()
	{
		if (isEating)
		{
			// Dejar de comer
			StopEating();
		}
		else
		{
			// Empezar a comer
			StartEating();
		}
	}

	/// <summary>
	/// Empezar a comer
	/// </summary>
	void StartEating()
	{
		if (nearbyFood == null || currentHunger >= maxHunger) return;

		isEating = true;

		// Activar animaciÃ³n de comer
		if (animator != null)
		{
			animator.SetBool("IsEating", true);
			animator.SetTrigger("Eat");
		}

		Debug.Log("ğŸ– Dinosaurio comenzÃ³ a comer");

		// Iniciar corrutina de comer
		StartCoroutine(EatingCoroutine());
	}

	/// <summary>
	/// Corrutina de comer
	/// </summary>
	System.Collections.IEnumerator EatingCoroutine()
	{
		while (isEating && currentHunger < maxHunger && nearbyFood != null)
		{
			// Aumentar hambre gradualmente
			currentHunger += eatingSpeed * Time.deltaTime;
			currentHunger = Mathf.Clamp(currentHunger, 0f, maxHunger);

			// Si se llenÃ³, dejar de comer automÃ¡ticamente
			if (currentHunger >= maxHunger)
			{
				Debug.Log("ğŸ– Dinosaurio estÃ¡ lleno!");
				StopEating();
				yield break;
			}

			yield return null;
		}

		// Si se alejÃ³ de la comida, dejar de comer
		if (nearbyFood == null)
		{
			StopEating();
		}
	}

	/// <summary>
	/// Dejar de comer
	/// </summary>
	void StopEating()
	{
		isEating = false;

		// Desactivar animaciÃ³n de comer
		if (animator != null)
		{
			animator.SetBool("IsEating", false);
		}

		StopCoroutine(EatingCoroutine());

		Debug.Log("ğŸ– Dinosaurio dejÃ³ de comer");
	}

	/// <summary>
	/// Alternar beber
	/// </summary>
	public void ToggleDrinking()
	{
		if (isDrinking)
		{
			// Dejar de beber
			StopDrinking();
		}
		else
		{
			// Empezar a beber
			StartDrinking();
		}
	}

	/// <summary>
	/// Empezar a beber
	/// </summary>
	void StartDrinking()
	{
		if (nearbyWater == null || currentThirst >= maxThirst) return;

		isDrinking = true;

		// Activar animaciÃ³n de beber
		if (animator != null)
		{
			animator.SetBool("IsDrinking", true);
			animator.SetTrigger("Drink");
		}

		Debug.Log("ğŸ’§ Dinosaurio comenzÃ³ a beber");

		// Iniciar corrutina de beber
		StartCoroutine(DrinkingCoroutine());
	}

	/// <summary>
	/// Corrutina de beber
	/// </summary>
	System.Collections.IEnumerator DrinkingCoroutine()
	{
		while (isDrinking && currentThirst < maxThirst && nearbyWater != null)
		{
			// Aumentar sed gradualmente
			currentThirst += drinkingSpeed * Time.deltaTime;
			currentThirst = Mathf.Clamp(currentThirst, 0f, maxThirst);

			// Si se llenÃ³, dejar de beber automÃ¡ticamente
			if (currentThirst >= maxThirst)
			{
				Debug.Log("ğŸ’§ Dinosaurio ya no tiene sed!");
				StopDrinking();
				yield break;
			}

			yield return null;
		}

		// Si se alejÃ³ del agua, dejar de beber
		if (nearbyWater == null)
		{
			StopDrinking();
		}
	}

	/// <summary>
	/// Dejar de beber
	/// </summary>
	void StopDrinking()
	{
		isDrinking = false;

		// Desactivar animaciÃ³n de beber
		if (animator != null)
		{
			animator.SetBool("IsDrinking", false);
		}

		StopCoroutine(DrinkingCoroutine());

		Debug.Log("ğŸ’§ Dinosaurio dejÃ³ de beber");
	}

	/// <summary>
	/// MÃ©todo pÃºblico para obtener hambre actual (usado por HealthSystem)
	/// </summary>
	public float GetCurrentHunger()
	{
		return currentHunger;
	}

	/// <summary>
	/// MÃ©todo pÃºblico para obtener sed actual (usado por HealthSystem)
	/// </summary>
	public float GetCurrentThirst()
	{
		return currentThirst;
	}

	/// <summary>
	/// MÃ©todo pÃºblico para verificar si estÃ¡ comiendo o bebiendo
	/// </summary>
	public bool IsEatingOrDrinking()
	{
		return isEating || isDrinking;
	}

	// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	// ğŸ“Š SISTEMA DE BARRAS UI
	// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	/// <summary>
	/// Actualiza las barras UI de hambre, sed y estamina
	/// </summary>
	void UpdateStatsUI()
	{
		// Actualizar barra de hambre
		if (hungerBar != null)
		{
			hungerBar.fillAmount = currentHunger / maxHunger;
		}

		// Actualizar barra de sed
		if (thirstBar != null)
		{
			thirstBar.fillAmount = currentThirst / maxThirst;
		}

		// Actualizar barra de estamina
		if (staminaBar != null)
		{
			staminaBar.fillAmount = currentStamina / maxStamina;
		}
	}

	// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	// ğŸ’€ SISTEMA DE MUERTE
	// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	/// <summary>
	/// MÃ©todo pÃºblico para matar al dinosaurio (llamado por HealthSystem)
	/// </summary>
	public void Die()
	{
		if (isDead) return;

		isDead = true;

		Debug.Log("ğŸ’€ Dinosaurio ha muerto!");

		// Detener todas las corrutinas activas
		StopAllCoroutines();

		// Detener estados
		isEating = false;
		isDrinking = false;
		isAttacking = false;
		isRunning = false;
		isCalling = false;

		// Activar animaciÃ³n de muerte
		if (animator != null)
		{
			animator.SetBool("IsDead", true);
			animator.SetTrigger("Death");

			// Desactivar otros parÃ¡metros
			animator.SetBool("IsEating", false);
			animator.SetBool("IsDrinking", false);
			animator.SetBool("IsAttacking", false);
			animator.SetBool("IsRunning", false);
			animator.SetFloat("Speed", 0f);
			animator.SetFloat("MoveX", 0f);
			animator.SetFloat("MoveZ", 0f);
		}

		// Desactivar el controlador de movimiento
		if (controller != null)
		{
			controller.enabled = false;
		}

		// Desactivar este script
		this.enabled = false;
	}
}

// Interface para objetos que pueden recibir daÃ±o
public interface IDamageable
{
    void TakeDamage(float damage);
}
